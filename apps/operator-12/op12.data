require("util/static")
Util = {}

--[[--
   keyup fallback
]]
function Util.KeyUp(key)
   if key == KEY_ESCAPE then
      static.quit()
   end
end

--[[--
   keydown fallback
]]
function Util.KeyDown(key)

end

--[[--
   resize fallback

   @param w 
   @param h 
]]
function Util.Resize(w, h)
   SCREEN_WIDTH = w
   SCREEN_HEIGHT = h
end

--[[--
   mousewheel fallback

   @param x 
   @param y 
]]
function Util.MouseWheel(x, y, dx, dy)
   
end

--[[--
   mousedown fallback

   @param x 
   @param y 
]]
function Util.MouseDown(x,y)

end

--[[--
   mousemove fallback

   @param x 
   @param y 
]]
function Util.MouseMove(x,y)

end

--[[--
   fallback

   @param x 
   @param y 
]]
function Util.MouseUp(x,y)

end

--[[--
   Take a class and make global the methods that are expected by C++

   @param controller 
]]
function Util.setController(controller)
   local f = {"Start", "Update", "End", "Resize", "KeyDown", "KeyUp", "MouseWheel", "MouseDown", "MouseMove", "MouseUp"}
   for i, v in ipairs(f) do
      if controller[v] then
	 rawset(_G, v, controller[v])
      else
	 rawset(_G, v, Util[v])
      end
   end
end

--[[--
   First class to call this becomes main.

   Hence there is a pattern of the first import being `require("util")` followed by local `isMain = Util.isMain()` - this guarentees the first loaded class will be main. Other require calls should follow this pattern.

   @return if caller is main 
]]
function Util.isMain()
   if Util.main then
      return false
   end
   Util.main = true
   return true
end

--[[--
   Make a controller the current controller if it says it's main

   @param isMain usually returned from Util.isMain()
   @param controller Controller to make current
]]
function Util.try(isMain, controller)
   if isMain then
      Util.setController(controller)
   end
end
import json
import os

def listall(path):
    things = sorted([x for x in os.listdir(path) if x != "contents.lua" and not x.endswith("~")])
    for i, thing in enumerate(things):
        if os.path.isdir(os.path.join(path, thing)):
            things[i] = thing + "/"
    with open(os.path.join(path, "contents.lua"), 'w') as f:
        f.write('return {' + ','.join([json.dumps(x) for x in things]) + '}') 
    for i, thing in enumerate(things):
        if os.path.isdir(thing):
            listall(os.path.join(path, thing))

listall(".")
return {"add-missing-docs.py","ai/","algorithms/","android.lua","battle/","cmd/","data/","dialogue/","fonts/","images/","level-select/","licenses/","listdir.py","load.lua","maps/","model/","money/","music-test.lua","sheets/","slug/","surface-tests.lua","text/","texture-tests.lua","tiled/","ui/","util/","util.lua","viewer/","world/"}function require(modname)
   if package.loaded[modname] then
      return package.loaded[modname]
   end
   local mod = Game.static.readfile(modname .. ".lua")
   local x = load(mod)
   if x == nil then
      x = true
   else
      x = x() or true
   end
   package.loaded[modname] = x
   return package.loaded[modname]
end

function dofile(fname)
   local mod = Game.static.readfile(fname)
   local x = load(mod, fname)
   if x then
      x = x()
   end
   return x
end

require("load")
return {
   load="load.lua",
   doInitSDL=true
}
require("util")
local isMain = Util.isMain()
require("flex/flex")
require("data/save")
require("ui/UIElement")
require("ui/ListButton")
require("level-select/load")
require("viewer/load")
require("world/load")
require("dialogue/overlay")
MainMenu = {}
local M = MainMenu

--[[--
   generic no-arg controller switcher
]]
function MainMenu.switchTo(controller)
   return function()
      M.End()
      Util.setController(controller)
      Start(0,{})
   end
end

function MainMenu.layout()
   local class = UIButton
   local rows, cols = 4, 4

   local space = {size={10, "dp"}}
   local childRow = {}
   local key = 1
   for i = 1, 2 * rows, 2 do
      local childCol = {}
      for j = 1, 2 * cols, 2 do
	 childCol[j] = space
	 childCol[j + 1] = {class=class,
						name=key,
			    size={1,"w"},
			    color="ff00ff"}
	 key = key + 1
      end
      childCol[2 * cols + 1] = space
      childRow[i] = space
      childRow[i + 1] = {axis=horizontal,
			 size={1,"w"},
			 children=childCol}
   end
   childRow[2 * rows + 1] = space
   
   return {
      axis=horizontal,
      children={
	 {axis=vertical,
	  size={1,"w"},
	  children=childRow}
      }
   }
end

--[[--
   on click callback to load credits
]]
function MainMenu.toCredits()
   M.End()
   Util.setController(Viewer)
   Start(3, {"viewer/load", "licenses/", "\n\n"})
end

--[[
   standard Flex mouse down

   @param x 
   @param y 
]]
function MainMenu.MouseDown(x,y)
   Flex.mouseDown(M, x, y)
end

--[[
   standard Flex mouse move

   @param x 
   @param y 
]]
function MainMenu.MouseMove(x,y)
   Flex.mouseMove(M, x, y)
end

--[[
   standard Flex mouse up

   @param x 
   @param y 
]]
function MainMenu.MouseUp(x,y)
   Flex.mouseUp(M, x, y)
end

function MainMenu.MouseWheel(x,y,dx,dy)
   Flex.mouseWheel(M, x, y, dx, dy)
end

--[[
   resize

   @param w 
   @param h 
]]
function MainMenu.Resize(w,h)
   Util.Resize(w,h)
   M.rects = Flex.calculateRects(M.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   Flex.setRects(M.views, M.rects)
   --UIElement.recalc(M.scene)
   --M.buttons:resize()
   
end

--[[--
   Basic menu setup
]]
function MainMenu.Start()
   M.cells = Flex.load("layout.lua")
   local named = Flex.getNamed(M.cells.children)
   named.main.size[1] = ListButton.heightOf(4, 60, 10)
   M.rects = Flex.calculateRects(M.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   M.views = Flex.new(M.cells, M.rects)
   named = Flex.getNamed(M.views)
   ListButton.init(named.main,
				   {M.switchTo(MapSelect),M.toCredits,M.switchTo(World),M.switchTo(Dialogue)},
				   {"Level Selection", "Credits/Thanks", "World Map Test", "Dialogue Test"},
				   60, 10)
   --[[local data = {"EEE", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p"}
   local named = Flex.getNamed(M.views) 
   for i, v in ipairs(data) do
	  local dat = {text=v, click=M.click}
	  if i > 6 then
		 dat = {color="00ff0000"}
	  end
      named[i]:setData(dat)
	  end]]
end

function MainMenu.click(object, pt)
   print("click reg @", pt[1], pt[2], object.text)
end

--[[
   draw things
]]
function MainMenu.Update()
   --Update=static.quit
   Flex.draw(M.views)
   --M.buttons:draw()
end

--[[
   destroy things
]]
function MainMenu.End()
   Flex.destroy(M.views)
   M.views = nil
   M.cells = nil
   M.rects = nil
end

Util.try(isMain, M)
import os
import re

p = re.compile("\n\nfunction [^\(]*\([^\)]*\)")
bd = re.compile("\s*return")
def matcher(obj):
    m = obj.group(0)
    args = m[m.index("(") + 1:m.index(")")]
    args = ([x.strip() for x in args.split(",") if len(x.strip()) > 0])
    docstr = "--[[\ndesc.\n" + "".join(["\n@param " + arg + " " for arg in args]) + ("\n" if len(args) > 0 else "") + "\n@return\n]]"
    return "\n\n" + docstr + m[1:]
def listall(path):
    things = sorted([x for x in os.listdir(path) if x != ".contents.lua" and x.endswith(".lua") and x.count(".") == 1 and os.path.isfile(os.path.join(path, x))])
    for name in things:
        full = os.path.join(path, name)
        contents = ""
        with open(full, "r") as f:
            contents = f.read()
        if bd.match(contents):
            #print("BAD")
            continue
        try:
            n = p.sub(matcher, contents)
            with open(full, "w") as f:
                f.write(n)
        except e:
            pass
        
    for thing in os.listdir(path):
        if os.path.isdir(thing):
            listall(os.path.join(path, thing))

            

listall(".")
return {
   load="load.lua",
   doInitSDL=true
}
return {
   axis=vertical,
   children={
	  {size={1,"w"}},
      {class=UIList,
	   axis = vertical,
	   name = "main",
       size={100,"dp"}},
	  {size={1,"w"}},
   }
}
require("util")
util.isMain()

UIView = Class()
require("util")

UIGroup = Class()
Flex.UIGroup = UIGroup

--[[
   arbitrary grouping ui class
]]
function UIGroup.new(cell, rect)
   local self = {}
   setmetatable(self, UIGroup)
   return self
end

function UIGroup:setRect(rect)
end

function UIGroup:setData(data)
   if self.children then
      Flex.setData(self.children, data)
   end
end

function UIGroup:draw()
end

function UIGroup:destroy()
end
require("util")
Util.isMain()

UIListGroup = Class()
function UIGroup.new(cell, rect)
   local self = {}
   setmetatable(self, UIGroup)
   return self
end

function UIGroup:setRect(rect)
end

function UIGroup:setData(data)
   Flex.setData(self.children, data)
end

function UIGroup:draw()
end

function UIGroup:destroy()
end
return {
   axis=vertical,
   children={
      {axis=horizontal,
       size={1,"w"},
       children={
	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},

	  {class=UIView,
	   size={1,"w"},
	   color="00ff00"},

	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},

	  {class=UIView,
	   size={1,"w"},
	   color="ff0000"},

	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},
      }},

      {class=UIView,
       size={1,"w"},
       color="0000ff"},
   }
}
<?xml version="1.0" encoding="UTF-8"?>
<Group>
  <View color="ff00ff"></View>
  <View color="0000ffcc"/>
  <Bird flying="true"/>
  <View color="0000ffcc"/>
</Group>
Flex = {
   rDrag = 10,
   horizontal = 1,
   vertical = 2,
}
require("flex/UIGroup")
require("flex/UIList")
require("flex/UITextBox")
require("flex/UIView")
require("flex/UIButton")

--[[--
   calculate the rects that views will take up given the
   parent rect (usually {0, 0, SCREEN_WIDTH, SCREEN_HEIGHT}
   and the view's layout cell.

   @param cell {axis=1|2, class=string, size={int, "dp"|"sp"|"w"}, children?={cell+}}
   @param rect {X, Y, W, H}
   @return rects of the cells
]]
function Flex.calculateRects(cell, rect, nolimit)
   local direction = cell.axis
   local odirection = 1
   if direction == 1 then
      odirection = 2
   else
      direction = 2
   end
   local size = rect[direction + 2]
   local osize = rect[odirection + 2]
   local x = rect[direction]
   local ox = rect[odirection]
   
   local flexible = size
   local weight = 0
   local children = cell.children
   -- calculate how much room standard things take up
   -- sum weights
   for i, child in ipairs(children) do
      local amount = child.size
      if amount[2] == "dp" then -- density dependant pix
		 flexible = flexible - amount[1]
      elseif amount[2] == "sp" then -- scalable pix
		 flexible = flexible - amount[1]
      elseif amount[2] == "w" then --weight
		 weight = weight + amount[1]
      end
   end
   local rects = {}
   --generate rects
   for i, child in ipairs(children) do
      local amount = child.size
      local mass = 0
      if amount[2] == "dp" then -- density dependant pix
		 mass = amount[1]
      elseif amount[2] == "sp" then -- scalable pix
		 mass = amount[1]
      elseif amount[2] == "w" and flexible >= 0 then --weight
		 mass = math.ceil(amount[1] / weight * flexible)
		 if mass > flexible then
			mass = flexible
		 end
		 flexible = flexible - mass
		 weight = weight - amount[1]
      end
      if not nolimit and mass > size then
		 mass = size
      end
      size = size - mass
      rects[i] = Flex.makebox(direction, odirection, x, ox, mass, osize)
      x = x + mass
   end

   --generate children rects
   for i, child in ipairs(children) do
      if child.children then
		 rects[i].children = Flex.calculateRects(child, rects[i])
      end
   end

   return rects
end

--[[--
   helper function to make a rect

   @param direction primary direction either 1|2 (horizontal|vertical)
   @param odirection secondary direction either 1|2 (horizontal|vertical)
   opposite of direction
   @param x position (x|y) of start of rect in the primary axis
   @param ox position (x|y) of start of rect in the secondary axis
   @param size size (width|height) of start of rect in the primary axis
   @param osize size (width|height) of start of rect in the secondary axis
   @return crafted rect
]]
function Flex.makebox(direction, odirection, x, ox, size, osize)
   local rect = {0, 0, 0, 0}
   rect[direction] = x
   rect[odirection] = ox
   rect[direction + 2] = size
   rect[odirection + 2] = osize
   return rect
end

--[[--
   Initialize the views given the layout (cell) and the rects
   these should occupy

   @param cell the layout
   @param rects generated by Flex.calculateRects
   @return newly created views
]]
function Flex.new(cell, rects)
   local views = {}
   views.n = #rects
   for i, rect in ipairs(rects) do
      local child = cell.children[i]
      if (not child.class) and child.children then
		 child.class = UIGroup
      end
      if child.class then
		 local class = child.class
		 views[i] = class.new(child, rect, i)
      end
      if child.children then
		 views[i].children = Flex.new(child, rect.children)
      end
   end
   return views
end

--[[--
   Set the rects of views
   
   @param views to have their rects set
   @param rects to set as the views' rects
]]
function Flex.setRects(views, rects)
   for i = 1, views.n do
      local child = views[i]
      local rect = rects[i]
      if child then
		 child:setRect(rect)
		 if child.children then
			Flex.setRects(child.children, rect.children)
		 end
      end
   end
end

--[[--
   is `pt` in `rect`
   @param pt point to check
   @param rect to test if in
   @return whether `pt` in `rect`
]]
function Flex.isInBound(pt, rect)
   return pt[1] >= rect[1] and pt[1] <= rect[1] + rect[3] and pt[2] >= rect[2] and pt[2] <= rect[2] + rect[4]
end

--[[
   Function that makes objectAtPoint work to find draggable objects
   @return returns nil if not a draggable object, object otherwise
]]
function Flex.doGetDraggable(object, pt)
   if object.draggable then
      return object
   end
end

--[[--
   If there is a draggable object at point fetch it
   @return returns nil if no a draggable object at point, view otherwise
]]
function Flex.getDraggable(pt, views, rects)
   return Flex.objectAtPoint(pt, views, rects, Flex.doGetDraggable)
end

--[[
   Function that makes objectAtPoint work as a clicking function
   @return non nil/false if click was consumed, nil/false otherwise
]]
function Flex.doClick(object, pt)
   if object.click then
      return object.click(object, pt)
   end
end

--[[--
   Do click at point
   @return non nil/false if click was consumed, nil/false otherwise
]]
function Flex.click(pt, views, rects)
   return Flex.objectAtPoint(pt, views, rects, Flex.doClick)
end

--[[--
   Apply a function to a view at a point
   @return result of calling fn on view at point
]]
function Flex.objectAtPoint(pt, views, rects, fn)
   for i = 1, views.n do
      local child = views[i]
      local rect = rects[i]
      if child and Flex.isInBound(pt, rect) then
		 if child.children then
			local result = Flex.objectAtPoint(pt, child.children, rect.children, fn)
			if result then
			   return result
			end
		 end
		 return fn(child, pt)
      end
   end
end

--[[--
   Get all named members of views
   @return dict of {name=view...}
]]
function Flex.getNamed(views)
   return Flex._getNamed(views, {})
end

--[[
   Helper. Get all named members of views
   @return dict of {name=view...}
]]
function Flex._getNamed(views, named)
   local len = views.n or #views
   for i = 1, len do
      local child = views[i]
      if child then
		 if child.name then
			named[child.name] = child
		 end
		 if child.children then
			Flex._getNamed(child.children, named)
		 end
      end
   end
   return named
end

--[[--
   Draw the views
]]
function Flex.draw(views)
   for i = 1, views.n do
      local child = views[i]
      if child then
		 views[i]:draw(0, 0)
		 if child.children then
			Flex.draw(child.children)
		 end
      end
   end
end

--[[--
   destroy the views
]]
function Flex.destroy(views)
   for i = 1, views.n do
      local child = views[i]
      if child then
		 views[i]:destroy()
		 if child.children then
			Flex.destroy(child.children)
		 end
      end
   end
end

--[[--
   Handles the common scenario of mouse wheel
   @param M module or object doing the clicking
   @param x coord
   @param y coord
   @param dx scroll dx
   @param dx scroll dy
]]
function Flex.mouseWheel(M, x, y, dx, dy)
   local draggable = Flex.getDraggable({x, y}, M.views, M.rects)
   if draggable then
      if dx < 0 then
	 dx = -10
      elseif dx > 0 then
	 dx = 10
      end
      if dy < 0 then
	 dy = -10
      elseif dy > 0 then
	 dy = 10
      end
      draggable:moveBy(dx, dy)
   end
   
   return draggable
end

--[[--
   Handles the common scenario of clicking / dragging mouse down
   @param M module or object doing the clicking
   @param x coord
   @param y coord
]]
function Flex.mouseDown(M, x, y)
   M.draggable = Flex.getDraggable({x, y}, M.views, M.rects)
   M.last = {x, y}
   M.dragging = false
end

--[[--
   Handles the common scenario of clicking / dragging mouse move
   @param M module or object doing the clicking
   @param x coord
   @param y coord
]]
function Flex.mouseMove(M, x, y)
   local last = M.last
   if M.draggable then
	  local dx = x - last[1]
	  local dy = y - last[2]
	  if M.dragging or math.abs(dx) > Flex.rDrag or math.abs(dy) > Flex.rDrag then
		 M.draggable:moveBy(dx, dy)
		 M.last = {x, y}
		 M.dragging = true
	  end
   end
end

--[[--
   Handles the common scenario of clicking / dragging mouse up
   @param M module or object doing the clicking
   @param x coord
   @param y coord
]]
function Flex.mouseUp(M, x, y)
   local result = true
   if not M.dragging then
	  result = Flex.click({x, y}, M.views, M.rects)
   end
   M.draggable = nil
   M.dragging = false
   M.last = nil
   return result
end

--[[--
   loads a file in the flex scope
]]
function Flex.load(fname)
   return uloadfile(fname, "bt", Flex)
end
return 
Flex = {}
--[[
{{1,"w"},{30,"dp"},children={}}
]]
function Flex.calculateRects(cell, rect)
   local direction = cell.axis
   local odirection = 1
   if direction == 1 then
      odirection = 2
   else
      direction = 2
   end
   local size = rect[direction + 2]
   local osize = rect[odirection + 2]
   local x = rect[direction]
   local ox = rect[odirection]
   
   local flexible = size
   local weight = 0
   local children = cell.children
   -- calculate how much room standard things take up
   -- sum weights
   for i, child in ipairs(children) do
      local amount = child.size
      if amount[2] == "dp" then -- density dependant pix
	 flexible = flexible - amount[1]
      elseif amount[2] == "sp" then -- scalable pix
	 flexible = flexible - amount[1]
      elseif amount[2] == "w" then --weight
	 weight = weight + amount[1]
      end
   end
   local rects = {}
   --generate rects
   for i, child in ipairs(children) do
      local amount = child.size
      local mass = 0
      if amount[2] == "dp" then -- density dependant pix
	 mass = amount[1]
      elseif amount[2] == "sp" then -- scalable pix
	 mass = amount[1]
      elseif amount[2] == "w" and flexible >= 0 then --weight
	 mass = math.ceil(amount[1] / weight * flexible)
	 if mass > flexible then
	    mass = flexible
	 end
	 flexible = flexible - mass
	 weight = weight - amount[1]
      end
      if mass > size then
	 mass = size
      end
      size = size - mass
      rects[i] = Flex.makebox(direction, odirection, x, ox, mass, osize)
      x = x + mass
   end

   --generate children rects
   for i, child in ipairs(children) do
      if child.children then
	 rects[i].children = Flex.calculateRects(child, rects[i])
      end
   end

   return rects
end

function Flex.makebox(direction, odirection, x, ox, size, osize)
   local rect = {0, 0, 0, 0}
   rect[direction] = x
   rect[odirection] = ox
   rect[direction + 2] = size
   rect[odirection + 2] = osize
   return rect
end
return {
   axis=vertical,
   children={
      {axis=horizontal,
       size={1,"w"},
       children={
	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},

	  {class=UIView,
	   name = "testing",
	   size={1,"w"},
	   color="00ff00"},

	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},

	  {class=UIView,
	   size={1,"w"},
	   color="ff0000"},

	  {class=UIView,
	   size={50,"dp"},
	   color="ff00ff"},
      }},

      {class=UIView,
       size={1,"w"},
       color="0000ff"},
   }
}
require("util")
local isMain = Util.isMain()
Flex = {}
local F = Flex
--[[
{{1,"w"},{30,"dp"},children={}}
]]
function Flex.calculate(cell, size, direction)
   local flexible = size
   local weight = 0
   -- calculate how much room standard things take up
   -- sum weights
   for i, child in ipairs(cell) do
      local amount = child[direction]
      if amount[2] == "dp" then -- density dependant pix
	 flexible = flexible - amount[1]
      elseif amount[2] == "sp" then -- scalable pix
	 flexible = flexible - amount[1]
      elseif amount[2] == "w" then --weight
	 weight = weight + amount[1]
      end
   end
   for i, child in ipairs(cell) do
      local amount = child[direction]
      local mass = 0
      if amount[2] == "dp" then -- density dependant pix
	 mass = amount[1]
      elseif amount[2] == "sp" then -- scalable pix
	 mass = amount[1]
      elseif amount[2] == "w" and flexible >= 0 then --weight
	 mass = math.ceil(amount[1] / weight * flexible)
	 if mass > flexible then
	    mass = flexible
	 end
	 flexible = flexible - mass
	 weight = weight - mass
      end
      if mass > size then
	 mass = size
      end
      size = size - mass
   end
end

function Flex.Start()
   
end

function Flex.Update()
   Update=static.quit()
end

function Flex.End()
   
end

Util.try(isMain, F)
require("util")
Util.isMain()

UITextBox = Class()
Flex.UITextBox = UITextBox

--[[
   A textbox that works with flex.

   complies with flex constructor.
]]
function UITextBox.new(cell, rect)
   local self = {}
   if cell.name then
	  self.name = cell.name
   end
   setmetatable(self, UITextBox)
   self:setProps(cell)

   -- rect not set, won't resize
   self:setText(cell.text)
   
   -- rect set (can now resize)
   self.rect = rect
   if self.rect then
	  self:setRect(self.rect)
   end
   return self
end

--[[
   set all textbox properties

   @param data
   @param data.fg foreground (text) color
   @param data.bg background color
   @param data.j justification
]]
function UITextBox:setProps(data)
   if not data then
	  data = {}
   end
   local fg = data.fg and {parseColor(data.fg)}
   local bg = data.bg and {parseColor(data.bg)}
   
   self.j = data.justify or self.j or 1
   self.fg = fg or self.fg or {255,255,255,255}
   self.bg = bg or self.bg or {0,0,0,0}
   self.direction = data.direction or self.direction
end


--[[--
   set boy's text

   @param text 
   @param start 
]]
function UITextBox:setText(text, start)
   self.text = text
   self:setStart(start)
end

--[[--
   set start position (doesn't do much yet? I forget)

   @param start 
]]
function UITextBox:setStart(start)
   self.start = start or 1
   if self.rect then
	  self:setRect(self.rect)
   end
end

--[[
   go to next unseen bit of text
   
   @return bool whether has shown all text already
]]
function UITextBox:next()
   local text = self.text
   self:setStart(self.start + self.displaying)
   local ltext = #text
   if self.start > ltext then
	  self.start = ltext + 1
   end
   return self.start > ltext
end

--[[
   set the boy's text
]]
function UITextBox:setRect(rect)
   self.rect = rect
   local r = self.rect
   self:destroy()
   if r[3] > 0 and r[4] > 0 then
	  local r = self.rect
	  local text = self.text
	  if self.start > #text then
		 text = ""
	  elseif self.start ~= 1 then
		 text = string.sub(text, self.start)
	  end
	  if self.direction == 2 then
		 local len, h = Text.charsInTextbox(
			self.text,
			r[3],
			r[4],
			2)
		 text = string.sub(text, #text - len + 1, -1)
	  end
	  local s, l, h = Text.textbox(
		 text,
		 self.j,
		 r[3],
		 r[4],
		 self.fg,
		 1)
	  self.displaying = l
	  local bg = self.bg or {255,128,128,255}
	  local s2 = Surface.newBlank(r[3], r[4])
	  Surface.fill(s2, 0, 0, r[3], r[4], bg[1], bg[2], bg[3], bg[4])
	  Surface.blit(s2, s, 0, 0)
	  self.tex = Surface.textureFrom(s2)
	  self.spr = Sprite.new(self.tex, r[1], r[2], r[3], r[4], 0, 0) -- sprite
	  Surface.destroy(s)
	  Surface.destroy(s2)
   end
end

--[[
   set the boy's data. don't use tbh
]]
function UITextBox:setData(data)
   self:setText(data.text, data.start)
end

--[[
   draw the boy
]]
function UITextBox:draw()
   if self.spr then
	  self.spr:draw(0,0)
   end
end

--[[
   destroy the boy
]]
function UITextBox:destroy()
   if self.spr then
	  self.spr:destroy()
	  self.spr = nil
   end
   if self.tex then
	  Texture.destroy(self.tex)
	  self.tex = nil
   end
end
require("util")
require("tiled/tilesets")
Util.isMain()

UIButton = Class()
function UIButton.new(cell, rect)
   local self = {rect=rect}
   self.color = cell.color
   setmetatable(self, UIButton)
   return self
end

function UIButton:setRect(rect)
   self.rect = rect
   local r = self.rect
   local s = Surface.newBlank(r[3], r[4])
   Surface.fill(s, 0, 0, r[3], r[4], parseColor(self.color)) 
   self.t = Surface.textureFrom(s)
   Surface.destroy(s)
end

function UIButton:setData(data)
   self:setRect(self.rect)
end

function UIButton:draw()
   local r = self.rect
   Texture.renderCopy(self.t, 0, 0, r[3], r[4], r[1], r[2], r[3], r[4])
end

function UIButton:destroy()
   if self.t then
      Texture.destroy(self.t)
   end
end
require("util")
local isMain = Util.isMain()
require("data/save")
require("flex/flex")
local F = Flex

function Flex.Start()
   cells = dofile("flex/test.layout.lua")
   rects = Flex.calculateRects(cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   things = Flex.new(cells, rects)
   Flex.setData(things, nil)
end

function Flex.Update()
   --Update=static.quit()
   Flex.draw(things)
end

function Flex.Resize(w, h)
   Util.Resize(w,h)
   rects = Flex.calculateRects(cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   Flex.setRects(things, rects)
end

function Flex.End()
   Flex.destroy(things)
end

Util.try(isMain, F)
require("util")
local isMain = Util.isMain()
require("data/save")
require("flex/flex")
local F = Flex

function Flex.Start()
   cells = dofile("flex/test.layout.lua")
   rects = Flex.calculateRects(cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   things = Flex.new(cells, rects)
   --Flex.setData(things, nil)
   print(table.tostring(Flex.getNamed(things)))
end

function Flex.End()
   Flex.destroy(things)
end

Util.try(isMain, F)
require("util")
Util.isMain()

UIButton = Class()
Flex.UIButton = UIButton

--[[
   Create a button, conforms to flex constructor
]]
function UIButton.new(cell, rect)
   local self = {rect=rect,text=cell.text}
   UIView.setBackground(self, cell)
   self.context = cell.context
   if cell.name then
	  self.name = cell.name
   end
   setmetatable(self, UIButton)
   if self.rect then
	  self:setRect(self.rect)
   end
   return self
end

--[[
   set the button's rect
]]
function UIButton:setRect(rect)
   self.rect = rect
   local r = self.rect
   self:destroy()
   if r[3] > 0 and r[4] > 0 then
      local s = UIView.makeBackground(self, rect)
	  if self.text and #self.text > 0 then
		 local text, l, h = Text.textbox(self.text, 2, r[3], r[4], {255,255,255,255})
		 Surface.blit(s, text, 0, (r[4] - h) // 2)
		 Surface.destroy(text)
	  end
      self.t = Surface.textureFrom(s)
      Surface.destroy(s)
   end
end

--[[
   set the button's data
]]
function UIButton:setData(data)
   UIView.setBackground(self, data)
   self.text = data.text
   self.fn = data.click -- click fn
   if self.rect then
	  self:setRect(self.rect)
   end
end

--[[
   click the button, respecting the desired context
]]
function UIButton:click(pt)
   if self.fn then
	  return self.fn(self.context, pt, self)
   end
end

--[[
   draw the button
]]
function UIButton:draw(x, y)
   if self.t then
      local r = self.rect
      Texture.renderCopy(self.t, 0, 0, r[3], r[4], r[1] + x, r[2] + y, r[3], r[4])
   end
end

--[[
   destroy the boy
]]
function UIButton:destroy()
   if self.t then
      Texture.destroy(self.t)
      self.t = nil
   end
end
return {
   load="flex/test-static.lua",
   doInitSDL=false
}
require("util")
require("tiled/tilesets")
Util.isMain()

UIView = Class()
Flex.UIView = UIView

--[[
   basic view for flex
]]
function UIView:makeBackground(rect)
   if self.color then
      local r = rect
      local s = Surface.newBlank(r[3], r[4])
      Surface.fill(s, 0, 0, r[3], r[4], parseColor(self.color))
      return s
   end
end

function UIView:setBackground(src)
   if not src then
      return
   end
   if src.color then
      self.color = src.color
   end
end

function UIView.new(cell, rect)
   local self = {rect=rect}
   setmetatable(self, UIView)
   if cell.name then
	  self.name = cell.name
   end
   self:setBackground(cell)
   return self
end

function UIView:setRect(rect)
   local r = rect
   self.rect = rect
   self:destroy()
   if r[3] > 0 and r[4] > 0 then
      local s = self:makeBackground(rect)
      self.t = Surface.textureFrom(s)
      Surface.destroy(s)
   end
end

function UIView:setData(data)
   self:setBackground(data)
   self:setRect(self.rect)
end

function UIView:draw()
   if self.t then
      local r = self.rect
      Texture.renderCopy(self.t, 0, 0, r[3], r[4], r[1], r[2], r[3], r[4])
   end
end

function UIView:destroy()
   if self.t then
      Texture.destroy(self.t)
      self.t = nil
   end
end
require("util")
Util.isMain()

UIList = Class()
Flex.UIList = UIList

--[[
   create a list, conforms to flex constructor
]]
function UIList.new(cell, rect)
   local self = {
	  rect = rect,
	  draggable = (cell.axis ~= nil),
	  delta = {0, 0},
	  axis = cell.axis,
   }
   UIView.setBackground(self, cell)
   if cell.name then
	  self.name = cell.name
   end
   setmetatable(self, UIList)
   return self
end

--[[
   set the list's data
   @param cells layout
   @param children already init'd views
]]
function UIList:setData(cells, children)
   self:destroy()
   self.cells = cells
    -- avoid sub-calls to children by different name
   self.c = children
   self:setRect(self.rect)
end

--[[
   set the boy's rect
]]
function UIList:setRect(rect)
   self.rect = rect
   if self.cells and self.c then
	  local cell = {
		 axis=vertical,
		 children = self.cells,
	  }
	  self.rects = Flex.calculateRects(cell, self.rect, true)
	  Flex.setRects(self.c, self.rects)
	  if self.draggable then
		 local height = 0
		 local a = self.axis
		 for i,v in ipairs(self.rects) do
			height = height + v[a + 2]
		 end
		 self.height = height
	  end
   end
end

--[[
   set the list's drag to dx, dy
]]
function UIList:moveTo(dx, dy)
   self.delta = {0, 0}
   self:moveBy(dx, dy)
end

--[[
   drag the list by dx, dy
   @param dx delta x
   @param dy delta y
]]
function UIList:moveBy(dx, dy)
   local d = {dx, dy}
   local a = self.axis
   local sd = self.delta
   sd[a] = sd[a] + d[a]
   local diff = self.height - self.rect[a + 2]
   if sd[a] < -diff then
	  sd[a] = -diff
   end
   if sd[a] > 0 then
	  sd[a] = 0
   end
end

--[[
   click the boy
]]
function UIList:click(pt)
   local d = self.delta
   pt = {pt[1] - d[1], pt[2] - d[2]}
   return Flex.click(pt, self.c, self.rects)
end

--[[
   draw the boy
]]
function UIList:draw()
   local r = {0, 0, SCREEN_WIDTH, SCREEN_HEIGHT}
   local rs = self.rect
   static.setRenderClip(rs[1], rs[2], rs[3], rs[4])
   local x = self.delta[1]
   local y = self.delta[2]
   local v = self.c
   for i = 1,v.n do
	  if v[i] then
		 v[i]:draw(x, y)
	  end
   end
   rs = r
   static.setRenderClip(rs[1], rs[2], rs[3], rs[4])
end

--[[
   destroy the boy
]]
function UIList:destroy()
   if self.c then
	  Flex.destroy(self.c)
   end
   self.rects = nil
   self.cells = nil
end

require("util")
require("tiled/tilesets")
Util.isMain()

UIView = Class()
function UIView.new(cell, rect)
   local self = {rect=rect}
   setmetatable(self, UIView)
   return self
end

function UIView:setData(cell, data)
   local r = self.rect
   local s = Surface.newBlank(r[3], r[4])
   Surface.fill(s, 0, 0, r[3], r[4], parseColor(cell.color)) 
   self.t = Surface.textureFrom(s)
   Surface.destroy(s)
end

function UIView:draw()
   local r = self.rect
   Texture.renderCopy(self.t, 0, 0, r[3], r[4], r[1], r[2], r[3], r[4])
end

function UIView:destroy()
   if self.t then
      Texture.destroy(self.t)
   end
end
return {
   load="load.lua",
   doInitSDL=false
}
return {
   axis=horizontal,
   children={

   }
}
--[[
   An image scaler that uses flex to decide the origin and destination rects.

   Usable for 9-slice or more interesting things like 11/13 slice
]]
--[[
   An image scaler that uses flex to decide the origin and destination rects.
]]
return {"Text.lua"}Text = {}

--[[--
   figures out how much of `text` can go on a line
   up to `width` pix long
   @param text text to fit
   @param width px
]]
function Text.charsInLine(text, width)
   local len = #text
   local best = 0
   local mini = 1
   local maxi = len
   local curi = len, w
   while mini <= maxi do
	  curi = (mini + maxi) // 2
	  w = TTF.size(string.sub(text, 1,curi))
	  if w < width then
		 if best < curi then
			best = curi
		 end
		 mini = curi + 1
	  elseif w > width then
		 maxi = curi - 1
	  else
		 return curi
	  end
   end
   w = TTF.size(string.sub(text, 1, curi))
   if w <= width and best < curi then
	  return curi
   end
   return best
end

--[[
   DON'T USE

   @deprecated
   @private

   figures out how much text can go on a line
   up to width pix long
]]
function Text.charsInLineRev(text, width)
   local len = #text
   local best = 0
   local mini = 1
   local maxi = len
   local curi = len, w
   local v
   while mini <= maxi do
	  curi = (mini + maxi) // 2
	  v = len - curi
	  w = TTF.size(string.sub(text, curi, len))
	  if w < width then
		 if best < v then
			best = v
		 end
		 maxi = curi - 1
	  elseif w > width then
		 mini = curi + 1
	  else
		 return v
	  end
   end
   w = TTF.size(string.sub(text, 1, curi))
   if w <= width and best < v then
	  return v
   end
   return best
end

--[[--
   generates text in a box as a surface

   @param text 
   @param align 
   @param w 
   @param h 
   @param c foreground color
   @param direction text direction {1=forwards, 2=backwards(DO NOT USE)}

   @return surface with rendered text
]]
function Text.textbox(text, align, w, h, c, direction)
   direction = direction or 1
   local charsInLine = Text.charsInLine
   if direction == 2 then
	  charsInLine = Text.charsInLineRev
   end
   local x, th = TTF.size("M")
   h = h // th
   local s = Surface.newBlank(w, h * th)
   local s2, y, tmp
   local l = 0
   local len = 0
   local spl
   for i = 1,h do
	  x = Text.charsInLine(text, w)
	  if x == 0 then
		 break
	  end
	  y = nil
	  if direction == 2 then
		 y = string.find(string.reverse(text),"\n",1,true)
	  else
		 y = string.find(text,"\n",1,true)
	  end
	  if y and y < x then
		 spl = y
		 if direction == 2 then
			spl = #text - y
		 end
		 if direction == 2 then
			tmp = string.sub(text,spl+2,-1)
			text = string.sub(text,1,spl)
		 else
			tmp = string.sub(text,1,spl-1)
			text = string.sub(text,spl+1,-1)
		 end
		 len = len + y
	  else
		 spl = x
		 if direction == 2 then
			spl = #text - x
		 end
		 tmp = string.sub(text,1,spl)
		 text = string.sub(text,spl+1,-1)
		 if direction == 2 then
			tmp, text = text, tmp
			if string.sub(text, -1, -1) == "\n" then
			   text = string.sub(text, 1, -2)
			end
		 else
			if string.sub(text, 1, 1) == "\n" then
			   text = string.sub(text, 2, -1)
			end
		 end
		 len = len + x
	  end
	  if #tmp > 0 then
		 y = (i-1)*th
		 if direction == 2 then
			y = (h-i)*th
		 end
		 s2 = TTF.surface(tmp, c[1],c[2],c[3],c[4])
		 if align == 1 then -- left align
			Surface.blit(s, s2,0,y)
		 elseif align == 2 then -- center align
			x = Surface.size(s2)
			Surface.blit(s, s2,(w - x) // 2,y)
		 elseif align == 3 then -- right
			x = Surface.size(s2)
			Surface.blit(s, s2,w-x,y)
		 end
		 Surface.destroy(s2)
		 l = i
	  end
	  s2 = nil
   end
   s2 = Surface.newBlank(w, h * th)
   if direction == 2 then
	  Surface.blit(s2, s, 0, -(h - l) * th)
   else
	  Surface.blit(s2, s, 0, 0)
   end
   Surface.destroy(s)
   return s2, len, l * th
end

--[[
   characters in a textbox

   @param text 
   @param w 
   @param h 
   @param direction 

   @return number of chars that can fit
]]
function Text.charsInTextbox(text, w, h, direction)
   direction = direction or 1
   local charsInLine = Text.charsInLine
   if direction == 2 then
	  charsInLine = Text.charsInLineRev
   end
   local x, th = TTF.size("M")
   h = h // th
   local y, tmp
   local l = 0
   local len = 0
   local spl
   for i = 1,h do
	  x = Text.charsInLine(text, w)
	  if x == 0 then
		 break
	  end
	  y = nil
	  if direction == 2 then
		 y = string.find(string.reverse(text),"\n",1,true)
	  else
		 y = string.find(text,"\n",1,true)
	  end
	  if y and y < x then
		 spl = y
		 if direction == 2 then
			spl = #text - y
		 end
		 if direction == 2 then
			tmp = string.sub(text,spl+2,-1)
			text = string.sub(text,1,spl)
		 else
			tmp = string.sub(text,1,spl-1)
			text = string.sub(text,spl+1,-1)
		 end
		 len = len + y
	  else
		 spl = x
		 if direction == 2 then
			spl = #text - x
		 end
		 tmp = string.sub(text,1,spl)
		 text = string.sub(text,spl+1,-1)
		 if direction == 2 then
			tmp, text = text, tmp
			if string.sub(text, -1, -1) == "\n" then
			   text = string.sub(text, 1, -2)
			end
		 else
			if string.sub(text, 1, 1) == "\n" then
			   text = string.sub(text, 2, -1)
			end
		 end
		 len = len + x
	  end
	  if #tmp > 0 then
		 l = i
	  end
   end
   return len, l * th
end
require("util")
Segment = Class()

--[[--
   creates a new segment
   @param p previous
   @param n next
   @param spr sprite - not owned by segment
   @param slug parent slug
   @param pos now owned by segment
   @param c connections
]]
function Segment.new (p, n, spr, pos, slug, c)
   local self = {p=p,n=n,spr=spr,pos=pos, slug=slug, c=c}
   setmetatable(self, Segment)
   self:insert(p, n)
   return self
end

--[[--
   Remove Segment from Map
]]
function Segment:removeFromMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = false
end

--[[--
   Add Segment to Map
]]
function Segment:addToMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = self
end

--[[--
   Unsets own connections and removes self from surrounding segments' connections.
]]
function Segment:unsetMapConnections()
   local deltas = {{0,-1},{1,0},{0,1},{-1,0}}
   local tmp
   local ind
   local cur = self.pos
   for c, d in ipairs(deltas) do
	  tmp = {cur[1] + d[1], cur[2] + d[2]}
	  self.c[c] = 0
	  if map:valid(tmp[1], tmp[2]) then
		 ind = map:indexOf(tmp[1], tmp[2])
		 if map.objects[ind] and map.objects[ind].slug == self.slug then
			map.objects[ind].c[((c + 1) & 3) + 1] = 0
		 end
	  end
   end
end

--[[--
   sets own connections self and adds self to surrounding segments' connecting c vals
]]
function Segment:setMapConnections() 
   local deltas = {{0,-1},{1,0},{0,1},{-1,0}}
   local tmp
   local ind
   local cur = self.pos
   for c, d in ipairs(deltas) do
	  tmp = {cur[1] + d[1], cur[2] + d[2]}
	  if map:valid(tmp[1], tmp[2]) then
		 ind = map:indexOf(tmp[1], tmp[2])
		 if map.objects[ind] and map.objects[ind].slug == self.slug then
			self.c[c] = 1
			--print(c, ((c + 1) & 3) + 1)
			map.objects[ind].c[((c + 1) & 3) + 1] = 1
		 end
	  else
		 self.c[c] = 0
	  end
   end
end

--[[--
   Draw on Map
]]
function Segment:draw()
   local x, y = Map.position(self.pos[1], self.pos[2])
   local s = self.spr
   local c = self.c
   local sep2 = (map.tilesep // 2)
   local w = tilew + sep2 * (c[2] + c[4])
   local h = tileh + sep2 * (c[1] + c[3])
   local dx = sep2 * c[4]
   local dy = sep2 * c[1]
   --print(c[1], c[2], c[3], c[4])
   Texture.renderCopy(s.tex, s.x-dx, s.y-dy, w, h, x-dx, y-dy, w, h)
   --   s:draw(x, y)
end

--[[--
   Removes Segment from chain
]]
function Segment:unlink()
   if self.p then
	  self.p.n = self.n
   end
   if self.n then
	  self.n.p = self.p
   end
   self.n = nil
   self.p = nil
end

--[[--
   link the next
]]
function Segment:linkN(n)
   n.p = self
   self.n = n
end

--[[--
   link the prev
]]
function Segment:linkP(p)
   p.n = self
   self.n = n
end

--[[
   gets c value index of `o` in relation to `self`

   `    1     `
   ` 4 self 2 `
   `    3     `
   @param o 

   @return index
]]
function Segment:cOf(o)
   if self.pos[2] > o.pos[2] then
	  return 1
   elseif self.pos[1] < o.pos[1] then
	  return 2
   elseif self.pos[2] < o.pos[2] then
	  return 3
   else
	  return 4
   end
end

--[[--
   insert between p - n
]]
function Segment:insert(p, n)
   local c
   if p then
	  p.n = self
   end
   if n then
	  n.p = self
   end
   self.p = p
   self.n = n
end

--[[
   print out info
]]
function Segment:print()
   print(self.slug.name, self.pos[1], self.pos[2])
end
return {"Skills.lua","segment.lua","slug.lua","slugdefs.lua"}return {
   tilesets={
      {
	 name = "heads",
	 tilewidth = 56,
	 tileheight = 56,
	 spacing = 0,
	 margin = 0,
	 image = "headsprites.png",
	 imagewidth = 168,
	 imageheight = 168,
	 tileoffset = {
	    x = 0,
	    y = 0
	 },
	 grid = {
	    orientation = "orthogonal",
	    width = 56,
	    height = 56
	 },
	 properties = {},
	 terrains = {},
	 tilecount = 9,
	 tiles = {
	    {
	       id = 0,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 1,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 2,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 3,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 4,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 5,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 6,
	       properties = {
		  ["color"] = "ffffff00"
	       }
	    }
	 }
      },
      {
	 name = "tails",
	 tilewidth = 56,
	 tileheight = 56,
	 spacing = 0,
	 margin = 0,
	 image = "tailsprites.png",
	 imagewidth = 168,
	 imageheight = 168,
	 tileoffset = {
	    x = 0,
	    y = 0
	 },
	 grid = {
	    orientation = "orthogonal",
	    width = 56,
	    height = 56
	 },
	 properties = {},
	 terrains = {},
	 tilecount = 9,
	 tiles = {
	    {
	       id = 0,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 1,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 2,
	       properties = {
		  ["color"] = "008cff"
	       }
	    },
	    {
	       id = 3,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 4,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 5,
	       properties = {
		  ["color"] = "ff7200"
	       }
	    },
	    {
	       id = 6,
	       properties = {
		  ["color"] = "00000000"
	       }
	    }
	 }
      }
   },
   slugs={
      test = {
	 tiles = {1,10},
	 stats={
	    moves = 5,
	    maxsize = 5,
	    skills={
	       {skill="Damage",
		range=1,
		damage=2
	       },
	       {skill="Flip",
		range=6
	       },
	       {skill="Heal",
		range=3,
		heal=10
	       }
	    }
	 }
      },
      test2 = {
	 tiles = {4, 13},
	 stats={
	    moves = 3,
	    maxsize = 3,
	    skills={
	       {skill="Damage",
		range=4,
		damage=1
	       }
	    }
	 }
      },
      spawner={
	 tiles={7,7},
	 stats={
	    moves = 0,
	    maxsize = 0,
	    skills={
	       {skill="Spawn",
		range=0
	       }
	    }
	 }
      }	  
   }
}
Skills = {
   Damage = {},
   Flip = {},
   Spawn = {},
   Heal = {}
}
local Damage = Skills.Damage
local Flip = Skills.Flip
local Spawn = Skills.Spawn
local Heal = Skills.Heal

--[[
   can initiator damage object

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Damage.can(initiator, object, _, _, _)
   if not object or not object.slug then
	  return false
   end
   local dx = object.pos[1]-initiator.head.pos[1]
   local dy = object.pos[2]-initiator.head.pos[2]
   if math.abs(dx) + math.abs(dy) <= initiator.action.range then
	  return object.slug.team ~= initiator.team
   end
   return false
end

--[[
   make initiator damage object

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Damage.act(initiator, object, _, _, _)
   object.slug:damage(initiator.action.damage)
end

--[[
   can initiator heal object

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Heal.can(initiator, object, _, _, _)
   if not object or not object.slug then
	  return false
   end
   local dx = object.pos[1]-initiator.head.pos[1]
   local dy = object.pos[2]-initiator.head.pos[2]
   if math.abs(dx) + math.abs(dy) <= initiator.action.range then
	  return object.slug.team == initiator.team
   end
   return false
end

--[[
   make initiator heal object

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Heal.act(initiator, object, _, _, _)
   --object.slug:damage(initiator.action.damage)
   local toHeal = initiator.action.heal
   local hasFrees = true
   local slug = object.slug
   local frees, cur
   while toHeal > 0 and hasFrees do
	  frees = {}
	  cur = slug.head
	  while cur do
		 Heal.addAllFreeNear(cur, frees)
		 cur = cur.n
	  end
	  for i, pos in ipairs(frees) do
		 if not map.objects[pos[3]] then
			slug.size = slug.size + 1
			toHeal = toHeal - 1
			cur = Segment.new(slug.tail, nil, slug.sprites[2], {pos[1],pos[2]}, slug, {0,0,0,0})
			slug.tail = cur
			cur:addToMap()
			cur:setMapConnections()
			if toHeal <= 0 then
			   break
			end
		 end
	  end
	  hasFrees = #frees > 0
   end
end

--[[
   add all the free spots near an object we could place newly spawned segements in

   @param object slug segment
   @param(out) frees list to insert free spaces into
]]
function Heal.addAllFreeNear(object, frees)
   local deltas = {{0,-1},{1,0},{0,1},{-1,0}}
   local pos = object.pos
   local x, y, ind
   for i,d in ipairs(deltas) do
	  x, y = pos[1] + d[1], pos[2] + d[2]
	  ind = map:indexOf(x, y)
	  if map:valid(x, y) and map.map[ind] and not map.objects[ind] then
		 table.insert(frees, {x,y,ind})
	  end
   end
end

--[[
   can slug flip a tile (bring it into existence or destroy it)

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Flip.can(initiator, object, ind, x, y)
   local dx = x-initiator.head.pos[1]
   local dy = y-initiator.head.pos[2]
   if math.abs(dx) + math.abs(dy) <= initiator.action.range then
	  return not object and map:valid(x,y)
   end
   return false
end

--[[
   flip a tile

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Flip.act(initiator, object, ind, x, y)
   if map.map[ind] then
	  map:destroyTile(ind)
   else
	  map:makeTile(ind, 1)
   end
end

--[[
   can spawn? not yet done

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Spawn.can(initiator, object, ind, x, y)
   return false
end

--[[
   do spawn (not yet done)

   @param initiator Slug doing the action
   @param object Map object at coordinates
   @param ind Map index
   @param x Coord x
   @param y Coord y
   @return whether action can run
]]
function Spawn.act(initiator, object, ind, x, y)
   return false
end
require("util")
require("tiled/tilesets")
-- slugdefs tells us information about slug types
-- such as where the head/body images are stored
Slug = {defs = dofile("slug/slugdefs.lua")}

Slug.__index = metareplacer(Slug)
require("slug/segment")

--[[--
   creates a new slug
   @param self now owned by slug, passed in unlike usual
   @return new slug
]]
function Slug.new (self)
   local sprites = Slug.defs[self.sprites].tiles
   self.stats = Slug.defs[self.sprites].stats
   self.sprites = {}
   for i, spr in ipairs(sprites) do
      self.sprites[i] = sprites[i]--Sprite.new(spr.tex, 0, 0, tilew, tileh, spr.x, spr.y)
   end
   self.size = #self.segs
   self.maxsize = self.stats.maxsize
   self.action = self.stats.skills[1]
   local prev = nil
   for i = 1,self.size do
      local sprite = self.sprites[2]
      if i == 1 then
	 sprite = self.sprites[1]
      end
      self.segs[i] = Segment.new(prev, nil, sprite, self.segs[i], self, {0,0,0,0})
      prev = self.segs[i]
   end
   self.head = self.segs[1]
   self.tail = self.segs[self.size]
   self.segs = nil
   setmetatable(self, Slug)
   self:addToMap()
   return self
end

--[[--
   creates the overlay for movement

   this overlay displays the maximum movement a slug can make with
   the `range` of moves it has left

   @param range number of moves slug has left
]]
function Slug:movementOverlay(range)
   local diamond = self:listDiamond(range)
   local arrs = {overlay.named.up, overlay.named.right, overlay.named.down, overlay.named.left}
   local x, y
   if #diamond < 4 then
      return
   end
   for i = 1, 4 do
      if diamond[i] then
	 x,y = Map.basePosition(diamond[i][1], diamond[i][2])
	 diamond[i] = Sprite.new(arrs[i].tex, x, y, tilew, tileh, arrs[i].x, arrs[i].y)
      end
   end
   local move = overlay.named.move
   for i = 5, #diamond do
      if diamond[i] then
	 x,y = Map.basePosition(diamond[i][1], diamond[i][2])
	 diamond[i] = Sprite.new(move.tex, x, y, tilew, tileh, move.x, move.y)
      end
   end
   self.overlay = diamond
end

--[[--
   creates a basic overlay

   calls the overlayFn to determine what of the diamond of squares in range
   should be displayed

   @param range how may tiles away does this overlay go
   @param overlayFn determines visible squares
]]
function Slug:basicOverlay(range, overlayFn)
   if not overlayFn then
      overlayFn = Slug.attackOverlayFn
   end
   local diamond = self:listDiamond2(range, overlayFn)
   local x, y
   local atk = overlay.named.attack
   for i = 1, #diamond do
      if diamond[i] then
	 x,y = Map.basePosition(diamond[i][1], diamond[i][2])
	 diamond[i] = Sprite.new(atk.tex, x, y, tilew, tileh, atk.x, atk.y)
      end
   end
   self.overlay = diamond
end

--[[--
   destroys current overlay
]]
function Slug:destroyOverlay()
   if self.overlay then
      for i,v in ipairs(self.overlay) do
	 if v then
	    v:destroy()
	 end
      end
   end
   self.overlay = nil
end

--[[--
   draws overlay
]]
function Slug:drawOverlay()
   if self.overlay then
      local x, y = Map.position(self.head.pos[1] + 1, self.head.pos[2] + 1)
      for i,v in ipairs(self.overlay) do
	 if v then
	    v:draw(x,y)
	 end
      end
   end
end

--[[--
   how to determine whether a square should have the attack overlay

   @param x coord
   @param y coord
   
   @return should show for coord
]]
function Slug.attackOverlayFn(x,y)
   return map:valid(x, y) and map.map[map:indexOf(x, y)]
end

--[[--
   creates a list of the coords that make up an overlay of a certain size

   @param size 
   @param overlayFn 

   @return list of coords (false replaces unwanted tiles)
]]
function Slug:listDiamond2(size, overlayFn)
   -- >v, <v,<^,>^
   local deltas = {{1,1},{-1,1},{-1,-1},{1,-1}}
   local j = 1
   local hpos = self.head.pos
   local pos = {0,0}--
   local lst = {}
   local x, y
   for ring = 1,size do
      pos[2] = pos[2] - 1
      for t,d in ipairs(deltas) do
	 for i=1,ring do
	    x, y = pos[1]+hpos[1], pos[2]+hpos[2]
	    if overlayFn(x, y) then
	       lst[j] = {pos[1], pos[2]}
	    else
	       lst[j] = false
	    end
	    pos[1] = pos[1] + d[1]
	    pos[2] = pos[2] + d[2]
	    j = j + 1
	 end
      end
   end
   return lst
end

--[[--
   same as `listDiamond2` above but using a breadth first search
   
   @param size 
   
   @return list of coords (false replaces unwanted tiles)
]]
function Slug:listDiamond(size)
   -- >v, <v,<^,>^
   local q = {s=0,e=1,n=1}
   local low = {0 - size, 0 - size}
   local visited = {}
   local tmp,cur,ind,mind,s
   local hpos = self.head.pos
   local x,y
   q[q.s] = {0,0,size}
   local deltas = {{0,-1},{1,0},{0,1},{-1,0}}
   local swidth = size*2 + 1
   while q.n >= 1 do
      cur = q[q.s]
      q.s = q.s + 1
      q.n = q.n - 1
      s = cur[3]
      for t,d in ipairs(deltas) do
	 tmp = {cur[1] + d[1], cur[2] + d[2],s-1}
	 --print(tmp[1],tmp[2],tmp[3])
	 if tmp[3] >= 0 and tmp[1] >= low[1] and tmp[1] < low[1] + swidth and tmp[2] >= low[2] and tmp[2] < low[2] + swidth then
	    ind = (tmp[1] - low[1]) + (tmp[2] - low[2])*swidth
	    x,y=tmp[1]+hpos[1], tmp[2]+hpos[2]
	    mind = map:indexOf(x, y)
	    if map:valid(x, y) and not visited[ind] and map.map[mind] then
	       --print("yes", ind)--), tmp[1]+hpos[1], tmp[2]+hpos[2], tmp[1], tmp[2], map.map[mind])
	       visited[ind] = true
	       q[q.e] = tmp
	       q.e = q.e + 1
	       q.n = q.n + 1
	    end
	 end
      end
   end
   deltas = {{1,1},{-1,1},{-1,-1},{1,-1}}
   local j = 1
   hpos = self.head.pos
   local pos = {0,0}--
   local lst = {}
   for ring = 1,size do
      pos[2] = pos[2] - 1
      for t,d in ipairs(deltas) do
	 for i=1,ring do
	    ind = (pos[1] - low[1]) + (pos[2] - low[2])*swidth
	    --print(ind)
	    if visited[ind] then
	       lst[j] = {pos[1], pos[2]}
	    else
	       lst[j] = false
	    end
	    pos[1] = pos[1] + d[1]
	    pos[2] = pos[2] + d[2]
	    j = j + 1
	 end
      end
   end
   return lst
end

--[[--
   spawn slugs from Tiled lua file
]]
function Slug.spawn(data)
   slugs = {}
   for i, v in ipairs(data) do
      if not slugs[v.name] then
	 slugs[v.name] = {}
      end
      --print(v.y, v.x, map.tilesize, map.width, (v.y // map.tilesize))
      slugs[v.name][v.properties.index] = {
	 (v.x // map.tilesize) + 1,
	 (v.y // map.tilesize) + 1
      }
      slugs[v.name].type = v.type
      if v.properties.team then
	 slugs[v.name].team = v.properties.team
      end
      if v.properties.spawner then
	 slugs[v.name].spawner = true
      end
   end
   for name, v in pairs(slugs) do
      slugs[name] = Slug.new({sprites = v.type, segs = v, name=name, team=v.team, spawner = v.spawner})
   end
end

--[[--
   despawn slugs from Tiled lua file
]]
function Slug.despawn()
   for name, v in pairs(slugs) do
      if v then
	 v:destroy()
      end
   end
   slugs = nil
end

--[[--
   load all slug data
   names -> textures
]]
function Slug.load ()
   local data = Slug.defs
   local tilesets = data.tilesets
   local slugdefs = data.slugs
   Tileset.loadSurfaces(tilesets)
   tilesets:colorBridge()
   tilesets:asTextures()
   tilesets:loadTilesets()
   for name, v in pairs(slugdefs) do
      for i, tile in ipairs(v.tiles) do
	 local j, dat = tilesets:tilefinder(tile)
	 if j then
	    local t = tilesets:initTile(tilesets[j],dat)
	    v.tiles[i] = t
	 end
      end
   end
   Slug.defs = slugdefs
   Slug.tilesets = tilesets
end

--[[--
   deallocate global slug textures
]]
function Slug.unload()
   Tileset.destroyTilesets(Slug.tilesets)
end

--[[--
   Remove Slug from Map
]]
function Slug:removeFromMap()
   local seg = self.head
   while seg do
      seg:unsetMapConnections()
      seg = seg.n
   end
   seg = self.head
   while seg do
      seg:removeFromMap()
      seg = seg.n
   end
end

--[[-- 
   Add Slug to Map
]]
function Slug:addToMap()
   local seg = self.head
   while seg do
      seg:addToMap()
      seg = seg.n
   end
   seg = self.head
   while seg do
      seg:setMapConnections()
      seg = seg.n
   end   
end

--[[--
   move slug's head to (x,y)
   
   Edge cases:
   - case off map
   - case encounter other
   - diagonal or on head
   - case encounter consumable
   - case encounter self tail
   - case encounter self (max len)
   - case encounter self default

   @param x
   @param y
]]
function Slug:move(x, y)
   local head = self.head
   local dx = math.abs(x - head.pos[1])
   local dy = math.abs(y - head.pos[2])
   local ind = map:indexOf(x,y)
   if not map:valid(x, y) or not map.map[ind] then
      return false
   end
   local mid = map.objects[ind]
   local item = nil
   if mid then
      if mid.item then
	 item = mid
	 mid = nil
      elseif mid.slug ~= self then
	 return false
      end
   end
   
   if dx > 1 or dy > 1 or dy == dx then
      return false
   end

   local tail = self.tail
   local ntail = nil
   local tx = tail.pos[1]
   local ty = tail.pos[2]
   head:unsetMapConnections()
   tail:unsetMapConnections()
   if mid and mid ~= tail then
      mid:unsetMapConnections()
   end
   head:removeFromMap()
   tail:removeFromMap()
   if mid and mid ~= tail then
      mid:removeFromMap()
      local t = mid.pos
      mid.pos = tail.pos
      tail.pos = t
      mid:addToMap()
      mid:unlink()
      mid:insert(tail.p, tail)
   end
   
   if tail ~= head then
      local prev = tail.p
      tail:unlink()	  
      tail:insert(head, head.n)
      tail.pos[1] = head.pos[1]
      tail.pos[2] = head.pos[2]
      tail:addToMap()
      if prev ~= head then
	 self.tail = prev
      end
   end
   head.pos[1] = x
   head.pos[2] = y
   head:addToMap()
   if not mid and self.size < self.maxsize then
      self.size = self.size + 1
      ntail = Segment.new(self.tail, nil, self.sprites[2], {tx,ty}, self, {0,0,0,0})
      self.tail = ntail
      ntail:addToMap()
      ntail:setMapConnections()
   end
   if mid and mid ~= tail then
      mid:setMapConnections()
   end
   head:setMapConnections()
   tail:setMapConnections()

   if item then
      item:take()
   end
   return true
end

--[[--
   remove `amount` segments from
   slug, possibly destroying it

   probably needs to be moved into Skills.lua now
   @param amount How many tiles to remove
]]
function Slug:damage(amount)
   for i = 1,amount do
      if self.size > 0 then
	 self.size = self.size - 1
	 local t = self.tail
	 t:unsetMapConnections()
	 t:removeFromMap()
	 self.tail = t.p
	 t:unlink()
	 if self.size <= 0 then
	    self:destroy()
	 end
      end
   end
end

--[[--
   deallocate slug
]]
function Slug:destroy ()
   self:destroyOverlay()
   if self.name and slugs[self.name] then
      slugs[self.name] = nil
   end
end
require("util")
require("model/var")
PlayerModel = Class()

function PlayerModel.new(data)
   if not data then
      data = {money=0}
   end
   local self = {data=data}
   setmetatable(self, PlayerModel)
   self.money = ModelVar.new(data, "money")
   return self
end

function PlayerModel:destroy()
   self.money = nil
   self.data = nil
end
return {"player.lua","var.lua"}require("util")

ModelVar = Class()

function ModelVar.new(holder, key)
   local self = {holder=holder, key=key}
   setmetatable(self, ModelVar)
   return self
end

function ModelVar:listen(listener)
   self.listener = listener
   listener:set(self.holder[key])
end

function ModelVar:add(value)
   local new = self.holder[key] + value
   self:set(new)
   return new
end

function ModelVar:get(value)
   return self.holder[key] + value
end

function ModelVar:set(value)
   self.holder[key] = value
   if self.listener then
      self.listener:set(self.holder[key])
   end
end
require("util")
require("model/var")
PlayerModel = Class()

function PlayerModel.new(data)
   if not data then
      data = {money=0}
   end
   self = {data=data}
   self.money = ModelVar.new(data, "money")
   setmetatable(self, PlayerModel)
   return self
end

function PlayerModel:destroy()
   self.money = nil
   self.data = nil
end
require("util")

ModelVar = Class()

function ModelVar.new(holder, key)
   local self = {holder=holder, key=key}
   setmetatable(self, ModelVar)
   return self
end

function ModelVar:listen(listener)
   self.listener = listener
   listener:set(self.holder[self.key])
end

function ModelVar:add(value)
   local new = self.holder[self.key] + value
   self:set(new)
   return new
end

function ModelVar:get()
   return self.holder[self.key]
end

function ModelVar:set(value)
   self.holder[self.key] = value
   if self.listener then
      self.listener:set(value)
   end
end
return {"load.lua"}return {
   load="viewer/load.lua",
   doInitSDL=true,
}
require("util")
local isMain = Util.isMain()
require("text/Text")
Viewer = {}
local V = Viewer

--[[--
   read all docs in a dir, and concat them together

   @param dir 
   @param sep 

   @return full text
]]
function Viewer.readAll(dir, sep)
   local texts = {}
   local sources = listdir(dir)
   for i, source in ipairs(sources) do
      texts[i] = static.readfile(dir..source)
   end
   return table.concat(texts, sep)
end

--[[--
   view all things in a dir

   @param argc 
   @param argv[2] dir
   @param argv[3] sep
]]
function Viewer.Start(argc, argv)
   if argc < 3 then	
      argv = {"viewer/load", "licenses/", "\n\n"}
   end
   V.stext = V.readAll(argv[2], argv[3])
   V.reset()
end

--[[
   resize

   @param w 
   @param h 

   @return
]]
function Viewer.Resize(w, h)
   SCREEN_WIDTH = w
   SCREEN_HEIGHT = h
   V.reset()
end

--[[
   reset viewer
]]
function Viewer.reset()
   local text = V.stext
   V.texts = {}
   V.page = 1
   local i = 1
   local l = Text.charsInTextbox(text, SCREEN_WIDTH, SCREEN_HEIGHT)
   while l > 0 do
      V.texts[i] = string.sub(text,1,l)
      text = string.sub(text,l + 1)
      i = i + 1
      l = Text.charsInTextbox(text, SCREEN_WIDTH, SCREEN_HEIGHT)
   end
   V.updateForPage(1)
end

--[[
   free viewer's stuff
]]
function Viewer.free()
   if V.tex then
      Texture.destroy(V.tex)
   end
   V.tex = nil
   if V.spr then
      V.spr:destroy()
   end
   V.spr = nil
end

--[[
   show page `p` of content

   @param p 
]]
function Viewer.updateForPage(p)
   if V.texts[p] == nil then
      return
   end
   V.free()
   V.page = p
   local sbox = Text.textbox(V.texts[V.page], 1, SCREEN_WIDTH, SCREEN_HEIGHT, {255,255,255,255})
   V.tex = Surface.textureFrom(sbox)
   V.spr = Sprite.new(V.tex, 0,0,SCREEN_WIDTH, SCREEN_HEIGHT,0,0)
   Surface.destroy(sbox)
end

--[[
   draw things
]]
function Viewer.Update()
   --Update = static.quit
   V.spr:draw(0,0)
end

--[[
   destroy things
]]
function Viewer.End()
   V.free()
   V.stext = nil
end

function Viewer.MouseDown(x,y)
   if x > SCREEN_WIDTH/2 then
      V.updateForPage(V.page + 1)
   else
      V.updateForPage(V.page - 1)
   end
end

--[[
   move around pages

   @param key 
]]
function Viewer.KeyDown(key)
   if key == KEY_ESCAPE then
      static.quit()
   elseif key == KEY_UP then
      V.updateForPage(V.page - 1)
   elseif key == KEY_DOWN then
      V.updateForPage(V.page + 1)
   elseif key == KEY_LEFT then
      V.updateForPage(V.page - 1)
   elseif key == KEY_RIGHT then
      V.updateForPage(V.page + 1)
   end
end

Util.try(isMain, V)
return {"load.lua"}return {
   load="level-select/load.lua",
   doInitSDL=true,
}
require("util")
local isMain = Util.isMain()
require("text/Text")
require("ui/Button")
require("ui/UIElement")
require("battle/load")
MapSelect = {}
local M = MapSelect

--[[--
   Button onclick, load map associated with button

   @param self Button
]]
function MapSelect.LoadFile(self)
   M.End()
   
   Util.setController(Battle)
   
   Start(2, {"battle/load", self.text})
end

--[[--
   Destroy all active buttons
]]
function MapSelect.destroyButtons()
   for i,b in ipairs(M.buttons) do
	  b:destroy()
   end
   M.buttons = {}
end

function MapSelect.layout()
   local class = UIView
   local rows, cols = 4, 4

   local space = {size={10, "dp"}}
   local childRow = {}
   local key = 1
   for i = 1, 2 * rows, 2 do
      local childCol = {}
      for j = 1, 2 * cols, 2 do
	 childCol[j] = space
	 childCol[j + 1] = {class=class,
			    size={1,"w"},
			    color="ff00ff",
			    key=key}
	 key = key + 1
      end
      childCol[2 * cols + 1] = space
      childRow[i] = space
      childRow[i + 1] = {axis=vertical,
			 size={1,"w"},
			 children=childCol}
   end
   childRow[2 * rows + 1] = space
   
   return {
      axis=vertical,
      children={
	 {axis=horizontal,
	  size={1,"w"},
	  children=childRow}
      }
   }
end

--[[--
   page select which maps to display

   @param p page number
]]
function MapSelect.updateForPage(p)
   M.destroyButtons()
   if p < 1 then
	  p = 1
   end
   if p > #M.maps then
	  p = #M.maps - 14
   else
	  M.page = p
   end
   for i = 0,15 do
	  local name = M.maps[i+M.page]
	  if name then
		 M.buttons[i + 1] = Button.new({text=name, layout=M.named[i+1], color={0,0,200,255}, click=M.LoadFile})
	  end
   end
end

--[[--
   Turn page/quit

   @param key 
]]
function MapSelect.KeyDown(key)
   if key == KEY_ESCAPE then
	  static.quit()
   elseif key == KEY_UP then
	  M.updateForPage(M.page - 14)
   elseif key == KEY_DOWN then
	  M.updateForPage(M.page + 14)
   elseif key == KEY_LEFT then
	  M.updateForPage(M.page - 14)
   elseif key == KEY_RIGHT then
	  M.updateForPage(M.page + 14)
   end
end

--[[--
   Loads list of available maps, will display them in a grid
]]
function MapSelect.Start()
   local btns = {}
   M.buttons = {}
   M.scene = {{s="screen",c=btns}}
   for i = 1,16 do
	  btns[i] = {n=i,s="button",d={(i-1)%4,(i-1)//4}}
   end
   M.named, M.scene = UIElement.getNamed(M.scene, dofile("ui/styles/map-select.style.lua"))
   --M.scene[1]:print()
   framedelay = 1000/10
   trueticks = framedelay
   M.page = 1
   M.maps = listdir("maps/")
   M.updateForPage(M.page)
   static.framedelay(framedelay)
end

--[[
   resize

   @param w 
   @param h 
]]
function MapSelect.Resize(w, h)
   SCREEN_WIDTH = w
   SCREEN_HEIGHT = h
   UIElement.recalc(M.scene)
   M.updateForPage(M.page)
end

--[[
   Draw, also tries to keep it close to the target framerate as an experiment

   @param t time since last frame as a fraction of a second
   @param ticks true ticks (ms) between last frame, can be 0
]]
function MapSelect.Update(t, ticks)
   --Update = static.quit
   for i,b in ipairs(M.buttons) do
	  b:draw()
   end
   local weight = 100
   trueticks = max(1, (trueticks * weight + trueticks - (ticks - framedelay))//(weight + 1))
   static.framedelay(trueticks)
end

--[[
   destroy things
]]
function MapSelect.End()
   M.destroyButtons()
end

--[[
   handle buttons

   @param x 
   @param y 

   @return
]]
function MapSelect.MouseDown(x,y)
   local b = Button.which(M.buttons, x,y)
   if b then
	  b:click(x,y)
   end
end

Util.try(isMain, M)
require("util")

Collectable = Class()
local C = Collectable
C.types = {}

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param take function to activate on collection
]]
function Collectable.new (spr, pos, take)
   local self = {spr=spr, pos=pos, take=take, item=true}
   setmetatable(self, C)
   return self
end

--[[--
   Remove from Map
]]
function Collectable:removeFromMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = false
end

--[[--
   Add to Map
]]
function Collectable:addToMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = self
end

--[[--
   Draw on Map
]]
function Collectable:draw()
   local x, y = Map.position(self.pos[1], self.pos[2])
   local s = self.spr
   local sep2 = (map.tilesep // 2)
   local w = tilew
   local h = tileh
   Texture.renderCopy(s.tex, s.x, s.y, w, h, x, y, w, h)
end

--[[--
   spawn collectables from Tiled lua file
   @param data sourced from tiled_map.layers[3].objects
]]
function Collectable.spawn(data)
   if not data then
      return
   end
   local collectables = {}
   C.items = collectables
   C.sheet = Tileset.fromSheet("collectables")
   for i, v in ipairs(data) do
      local item = C.types[v.type].spawn(v, {
	 (v.x // map.tilesize) + 1,
	 (v.y // map.tilesize) + 1
      })
      table.insert(collectables, item)
      item:addToMap()
   end
end

--[[--
   Destroys associated objects created in the spawn function
]]
function Collectable.despawn()
   if C.sheet then
      C.sheet:destroyTilesets()
   end
   C.sheet = nil
   C.items = nil
end
return {"collectable.lua","goal-object.lua","load.lua","map.lua","overlay.lua","selection-mode.lua","ui.lua"}require("util")
require("ai/ai")
SlugSelect = {}
local S = SlugSelect

--[[--
   callback gen, set active choice to slug.

   should probably update textbox text

   @param i index into choice
   @param slugs slugs

   @return callback
]]
function SlugSelect.fn(i, slugs)
   return function()
      S.choice = slugs[i]
   end
end

--[[--
   Set up buttons so one can choose which slug to place.

   Should include pagination.
]]
function SlugSelect.setUI()
   local slugs = S.inv.slugs
   local fns = {}
   local texts = {}
   for i = 1,#slugs do
      table.insert(fns, S.fn(i, slugs))
      table.insert(texts, slugs[i].type)
   end
   table.insert(texts,"done")
   table.insert(fns, S.Finish)
   BattleUI.named.info:setData({text="Click a slug type, then click a spawn-spot to set the slug!"})
   BattleUI.setButtons(fns,texts)
   --BattleUI.t:resize()
end

--[[--
   Sets self as controller, takes some functions from Battle
   Loads possible slug choices for use

   @param inv Player's inventory
]]
function SlugSelect.Begin(inv)
   for i,v in pairs({"Resize", "Start", "End"}) do
      S[v] = Battle[v]
   end

   Util.setController(S)
   S.inv = inv
   S.mates = AI.findSpawners()
   
   S.imates = {}
   S.choices = {}
   
   for i,m in ipairs(S.mates) do
      S.imates[map:indexOf(m.pos[1], m.pos[2])] = true
   end

   S.setUI()
end

--[[--
   cleans up memory, hands control back to Battle
]]
function SlugSelect.Finish()
   local spawners = slugs["spawner"]
   if spawners then
      spawners:damage(spawners.size)
   end
   for i,c in ipairs(S.choices) do
      local name = "spawned-"..i
      slugs[name] = Slug.new({sprites = c[3].type, segs = {{c[1],c[2]}}, name=name, team=1, spawner = false})
   end
   S.inv = nil
   S.choice = nil
   S.choices = nil
   S.mates = nil
   S.imates = nil
   Util.setController(Battle)
   Player.prepareForTurn()
end

--[[--
   draw things, update map
]]
function SlugSelect.Update()
   --Update = static.quit
   map:update()
   map:draw()
   for i,v in ipairs(S.choices) do
      local x,y,s = v[1],v[2],v[3].type
      local t = Slug.defs[s].tiles[1]
      x, y = Map.basePosition(x, y)
      Texture.renderCopy(t.tex,
			 t.x,t.y,t.w,t.h,
			 x + map.x,
			 y + map.y,
			 map.tilesize,
			 map.tilesize)
   end
   BattleUI.draw()
end

function SlugSelect.PlaceSlug(x, y)
   local px, py = Map.positionToCoords(x,y)	  
   if map:valid(px, py) then
      local ind = map:indexOf(px, py)
      if not S.imates then return end -- Player didn't spawn any slugs this time      
      if S.imates[ind] and S.choice then -- Player wants to spawn a slug
	 local choice = {px, py, S.choice}
	 if S.imates[ind] ~= true then
	    S.choices[S.imates[ind]] = choice
	 else
	    local cind = #S.choices + 1
	    table.insert(S.choices, cind, choice)
	    S.imates[ind] = cind
	 end
      end
   end
end

function SlugSelect.MouseWheel(x,y,dx,dy)
   BattleUI.MouseWheel(x, y, dx, dy)
end

--[[--
   either click buttons, or try and place a slug

   @param x 
   @param y 
]]
function SlugSelect.MouseDown(x,y)
   BattleUI.MouseDown(x,y)
end

function SlugSelect.MouseMove(x, y)
   BattleUI.MouseMove(x, y)
end

function SlugSelect.MouseUp(x, y)
   if BattleUI.MouseUp(x, y) then
      return
   end
   SlugSelect.PlaceSlug(x, y)
end

--[[--
   pan camera about map or quit

   @param key 
]]
function SlugSelect.KeyDown(key)
   if key == KEY_ESCAPE then
      static.quit()
   elseif key == KEY_UP then
      map.dy = -map.speed
   elseif key == KEY_DOWN then
      map.dy = map.speed
   elseif key == KEY_LEFT then
      map.dx = -map.speed
   elseif key == KEY_RIGHT then
      map.dx = map.speed
   end
end

--[[--
   Stop panning or quit

   @param key 
]]
function SlugSelect.KeyUp(key)
   if key == KEY_ESCAPE then
      static.quit()
   elseif key == KEY_UP and map.dy < 0 then
      map.dy = 0
   elseif key == KEY_DOWN and map.dy > 0 then
      map.dy = 0
   elseif key == KEY_LEFT and map.dx < 0 then
      map.dx = 0
   elseif key == KEY_RIGHT and map.dx > 0 then
      map.dx = 0
   end
end
require("util")
require("battle/collectable")
require("battle/goal-object")
require("money/object")
require("model/player")
Map = Class()

Map.tilesep = 10
Map.tilesize = 40 -- rewritten

--[[--
   create a new Map

   could display in a more efficient way but like it works fine.
   
   @param data passed in from Tiled data
   (map assumes control of data)/will corrupt it.
]]
function Map.new (data)
   tilew = data.tilesets[1].tilewidth
   tileh = data.tilesets[1].tileheight
   local tilesets = data.tilesets
   for i, v in ipairs(tilesets) do
      local t, w, h = Texture.new("images/" .. v.image)
      v.sheet = t
      v.w = w // v.tilewidth
   end
   local tilesize = tilew
   Map.tilesize = tilesize
   local tilesep = 10
   local tmap = data.layers[1].data
   local objects = {}
   local t = {map=tmap,
	      objects = objects,
	      tilesets=tilesets,
	      width=data.width,
	      height=data.height,
	      x=0,
	      y=0,
	      dx=0, dy=0, speed=5}
   --print(t.x, t.y)
   setmetatable(t, Map)
   map = t
   for i, dat in ipairs(tmap) do
      t:makeTile(i, dat)
   end
   if #data.layers >= 3 then
      Collectable.spawn(data.layers[3].objects)
   end
   Slug.load()
   Slug.spawn(data.layers[2].objects)
   for k,v in pairs(slugs) do
      t.slug = v
   end
   t:recenter()
   return t
end


--[[--
   recenter the map in the display
]]
function Map:recenter()
   self.x = (SCREEN_WIDTH - (self.width * (self.tilesize + self.tilesep) - self.tilesep))//2
   self.y = (SCREEN_HEIGHT - (self.height * (self.tilesize + self.tilesep) - self.tilesep))//2
end



--[[--
   make a map tile, adds it to the map

   @param i map index
   @param dat tile number
]]
function Map:makeTile(i, dat)
   local tilesets = self.tilesets
   local tmap = self.map
   local objects = self.objects
   objects[i] = false
   local j = 1
   if dat <= 0 then
      tmap[i] = false
   else
      while dat > tilesets[j].tilecount do
	 dat = dat - tilesets[j].tilecount
	 j = j + 1
      end
      
      local v = tilesets[j]
      dat = dat - 1
      local x, y = Map.basePosition((i-1) % self.width + 1, (i-1) // self.width + 1)
      tmap[i] = Sprite.new(v.sheet,
			   x,
			   y,
			   self.tilesize,
			   self.tilesize,
			   (dat % v.w)*v.tilewidth,
			   (dat // v.w)*v.tileheight)
   end
end

--[[--
   destroy an individual tile

   @param i map index
]]
function Map:destroyTile(i)
   if self.map[i] then
      self.map[i]:destroy()
      self.map[i] = false
   end
end

--[[--
   convert x,y map postion to an index

   @param x 1 based x index
   @param y 1 based x index

   @return map index
]]
function Map:indexOf(x,y)
   return (x-1) + (y - 1) * self.width + 1
end

--[[--
   pan map
]]
function Map:update()
   self.x = self.x - self.dx
   self.y = self.y - self.dy
end

--[[--
   is an (x,y) coord in bounds

   @param x 
   @param y 

   @return in bounds
]]
function Map:valid(x, y)
   return x >= 1 and y >= 1 and x <= self.width and y <= self.height
end

--[[--
   convert input position to map coordinates

   @param x Screen-space position
   @param y Screen-space position

   @return x, y - map-space postion
]]
function Map.positionToCoords(x,y)
   return (x - map.x)//(Map.tilesize + Map.tilesep) + 1,
   (y - map.y)//(Map.tilesize + Map.tilesep) + 1
end

--[[
   get map pixel position from grid coords
]]
function Map.position(x,y)
   --ehhhhhh global var abuse but like who cares rn
   return ((x - 1) * (Map.tilesize + Map.tilesep) + map.x), ((y - 1) * (Map.tilesize + Map.tilesep) + map.y)
end

-- get map pixel position from grid coords
function Map.basePosition(x,y)
   --ehhhhhh global var abuse but like who cares rn
   return ((x - 1) * (Map.tilesize + Map.tilesep)), ((y - 1) * (Map.tilesize + Map.tilesep))
end

-- click on map -> do someting 
function Map:mousedown(x,y)
   local x,y = Map.positionToCoords(x,y)
   if x > 0 and x <= self.width and y > 0 and y <= self.width then
      if self.slug then
	 self.slug:move(x, y)
      end
   end
end

function Map:moveBy(x, y)
   self.x = self.x + x
   self.y = self.y + y
end

-- draw map to screen
function Map:draw()
   local i = 1
   local v
   local tx = self.x
   local ty = self.y
   for y = 1,self.height do
      if ty + self.tilesize > 0 and ty < SCREEN_HEIGHT then
	 tx = self.x
	 for x = 1,self.width do
	    if tx + self.tilesize > 0 and tx < SCREEN_WIDTH then
	       v = self.map[i]
	       if v then
		  v:draw(self.x, self.y)
	       end
	       if self.objects[i] then
		  self.objects[i]:draw()
	       end
	    end
	    i = i + 1
	    tx = tx + self.tilesize + self.tilesep
	 end
      else
	 i = i + self.width
      end
      ty = ty + self.tilesize + self.tilesep
   end
end

-- deallocate map
function Map:destroy()
   for i, v in ipairs(self.tilesets) do
      Texture.destroy(v.sheet)
   end

   for i, v in ipairs(self.map) do
      if v then
	 v:destroy()
      end
   end

   Slug.despawn()
   Collectable.despawn()
end
require("util")
require("battle/collectable")

GoalObject = {}
Collectable.types.goal = GoalObject

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
]]
function GoalObject.new (spr, pos, value)
   return Collectable.new(spr, pos, value, GoalObject.take)
end

--[[--
   spawn a new money object from a tiled object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
]]
function GoalObject.spawn (v, pos)
   return GoalObject.new(Collectable.sheet.goal, pos, v.properties.value)
end

--[[--
   called to capture the money for a player/slug
   @param player player that took money
   @param slug slug that took money
]]
function GoalObject:take(player, slug)
   self:removeFromMap()
   player.money:add(self.value)
end
require("util")
require("ui/ListButton")
require("ui/TextBox")
require("money/ui")
BattleUI = {bHeight=30, bSpace=10}
local B = BattleUI

--[[--
   Makes the list button and text box that is gonna be displaying the slug's stats
]]
function BattleUI.init()
   B.cells = Flex.load("battle/layout.lua")
   local named = Flex.getNamed(B.cells.children)
   named.actions.size[1] = ListButton.heightOf(3, B.bHeight, B.bSpace) + B.bSpace + B.bHeight // 2
   B.rects = Flex.calculateRects(B.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   B.views = Flex.new(B.cells, B.rects)
   B.named = Flex.getNamed(B.views)
   BattleUI.setButtons({}, {})
   local money = MoneyUI.new(B.named)
   player.money:listen(money)
end

--[[--
   Get the text that our actions List is supposed to display as the slug's overall info

   @param slug Slug we need info of.

   @return said text
]]
function BattleUI.getSlugText(slug)
   local s = slug.stats
   return table.concat({"moves: ", tostring(s.moves),"\n",
			"max size: ", tostring(s.maxsize),"\n"})
end

--[[--
   On actions click closure generater

   sets slug attack mode; moves slug onto attack phase

   @param i Index of skill
   @param slug slug in focus

   @return a on click closure
]]
function BattleUI.fn(i, slug)
   return function ()
      slug.action = slug.stats.skills[i]
      Player.beginAttack()
      return true
   end
end

--[[--
   set slug in focus

   @param slug our focus
]]
function BattleUI.setSlug(slug)
   local s = slug.stats
   local fns = {}
   local texts = {}
   for i = 1,#slug.stats.skills do
      table.insert(fns, B.fn(i, slug))
      table.insert(texts, slug.stats.skills[i].skill)
   end
   B.slug = slug
   B.setButtons(fns, texts)
   B.named.info:setData({text=B.getSlugText(slug)})
   --B.actions:setButtons(fns,texts)
   --B.t:resize()
end

function BattleUI.setButtons(fns, texts, context)
   ListButton.init(B.named.actions,
				   fns,
				   texts,
				   B.bHeight, B.bSpace, context)
end

--[[--
   resize things
]]
function BattleUI.resize()
   B.rects = Flex.calculateRects(B.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   Flex.setRects(B.views, B.rects)
end

--[[--
   draw things
]]
function BattleUI.draw()
   Flex.draw(B.views)
end

--[[--
   destroy things
]]
function BattleUI.destroy()
   Flex.destroy(B.views)
   B.slug = nil
   B.scene = nil
   B.named = nil
   B.views = nil
   B.cells = nil
   B.rects = nil
   B.map = nil
   B.draggable = nil
end

--[[
   standard Flex mouse down

   @param x 
   @param y 
]]
function BattleUI.MouseDown(x,y)
   Flex.mouseDown(B, x, y)
   if B.draggable then
	  return true
   end
   B.draggable = B.map
   return true
end

--[[
   standard Flex mouse move

   @param x 
   @param y 
]]
function BattleUI.MouseMove(x,y)
   Flex.mouseMove(B, x, y)
end

function BattleUI.MouseWheel(x,y,dx,dy)
   if not Flex.mouseWheel(B, x, y, dx, dy) then
      if dx < 0 then
	 dx = -10
      elseif dx > 0 then
	 dx = 10
      end
      if dy < 0 then
	 dy = -10
      elseif dy > 0 then
	 dy = 10
      end
      if B.map then
	 B.map:moveBy(dx, dy)
      end
   end
end

--[[
   standard Flex mouse up

   @param x 
   @param y 
]]
function BattleUI.MouseUp(x,y)
   return Flex.mouseUp(B, x, y)
end
require("util")
require("battle/collectable")

GoalObject = {}
Collectable.types.goal = GoalObject

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
]]
function GoalObject.new (spr, pos)
   return Collectable.new(spr, pos, GoalObject.take)
end

--[[--
   spawn a new money object from a tiled object
   @param unused a tiled object
   @param value money the object will impart on capture
]]
function GoalObject.spawn (unused, pos)
   return GoalObject.new(Collectable.sheet.named.goal, pos)
end

--[[--
   called to capture the money for a player/slug
   @param player player that took money
   @param slug slug that took money
]]
function GoalObject:take(slug)
   Player.win()
end
return {
   load="battle/load.lua",
   doInitSDL=true,
}
return {
  name = "overlay",
  tilewidth = 56,
  tileheight = 56,
  spacing = 0,
  margin = 0,
  image = "arrs.png",
  imagewidth = 168,
  imageheight = 112,
  tileoffset = {
    x = 0,
    y = 0
  },
  grid = {
    orientation = "orthogonal",
    width = 64,
    height = 64
  },
  properties = {},
  terrains = {},
  tilecount = 6,
  tiles = {
    {
      id = 0,
      type = "up",
      properties = {
        ["color"] = "0000"
      }
    },
    {
      id = 1,
      type = "left",
      properties = {
        ["color"] = "0000"
      }
    },
    {
      id = 2,
      type = "right",
      properties = {
        ["color"] = "0000"
      }
    },
    {
      id = 3,
      type = "down",
      properties = {
        ["color"] = "0000"
      }
    },
    {
      id = 4,
      type = "attack",
      properties = {
        ["color"] = "0000"
      }
    },
    {
      id = 5,
      type = "move",
      properties = {
        ["color"] = "0000"
      }
    }
  }
}
require("util")
local isMain = Util.isMain()
require("battle/map")
require("ai/ai")
require("ai/player")
require("tiled/tilesets")
require("battle/ui")
require("battle/selection-mode")
Battle = {}

--[[--
Load the slugs, load the map, prepare for battle

@param argv[2] name of map to load
]]
function Battle.Start(argc, argv)
   player = PlayerModel.new()
   name = argv[2]
   dofile("slug/slug.lua")
   framedelay = 1000//60
   if name == nil then
	  name = "test.lua"
   end
   map = Map.new(dofile("maps/"..name))
   overlay = {dofile("battle/overlay.lua")}
   Tileset.loadSurfaces(overlay)
   overlay:asTextures()
   overlay:loadTilesets()
   BattleUI.init()
   BattleUI.map = map
   static.framedelay(framedelay)
   SlugSelect.Begin(dofile("data/static/inv.lua"))
end

--[[
   resize things

   @param w 
   @param h 
]]
function Battle.Resize(w, h)
   SCREEN_WIDTH = w
   SCREEN_HEIGHT = h
   map:recenter()
   BattleUI.resize()
end

--[[--
draw things, update map
]]
function Battle.Update()
   --Update = static.quit
   map:update()
   map:draw()
   if Player.slug then
	  Player.slug:drawOverlay()
   end
   BattleUI.draw()
end

--[[
destroy things
]]
function Battle.End()
   Tileset.destroyTilesets(overlay)
   overlay = nil
   Slug.unload()
   map:destroy()
   BattleUI.destroy()
   map = nil
   player:destroy()
   player = nil
end

--[[--
   pan camera about map or quit

@param key 
]]
function Battle.KeyDown(key)
   if key == KEY_ESCAPE then
	  static.quit()
   elseif key == KEY_UP then
	  map.dy = -map.speed
   elseif key == KEY_DOWN then
	  map.dy = map.speed
   elseif key == KEY_LEFT then
	  map.dx = -map.speed
   elseif key == KEY_RIGHT then
	  map.dx = map.speed
   end
end

--[[--
Stop panning or quit

@param key 
]]
function Battle.KeyUp(key)
   if key == KEY_ESCAPE then
	  static.quit()
   elseif key == KEY_UP and map.dy < 0 then
	  map.dy = 0
   elseif key == KEY_DOWN and map.dy > 0 then
	  map.dy = 0
   elseif key == KEY_LEFT and map.dx < 0 then
	  map.dx = 0
   elseif key == KEY_RIGHT and map.dx > 0 then
	  map.dx = 0
   elseif key == KEY_SPACE then
	  if active == Player.move then
		 Player.beginAttack()
	  elseif active == Player.attack then
		 Player.nextTurn()
	  end
   end
end

function Battle.MouseWheel(x,y,dx,dy)
   BattleUI.MouseWheel(x, y, dx, dy)
end

--[[
   Trigger movement/attack or whatever other action is currently active

@param x 
@param y 

@return
]]
function Battle.MouseDown(x, y)
   BattleUI.MouseDown(x,y)
end

function Battle.MouseMove(x, y)
   BattleUI.MouseMove(x, y)
end

function Battle.MouseUp(x, y)
   if BattleUI.MouseUp(x, y) then
	  return
   end
   if active ~= nil then
	  local px, py = Map.positionToCoords(x,y)	  
	  active(px,py)
   end
end

Util.try(isMain, Battle)
require("util")

Collectable = class()
local C = Collectable

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
   @param take function to activate on collection
]]
function C.new (spr, pos, value, take)
   local self = {spr=spr, pos=pos, v=value, take=take}
   setmetatable(self, C)
   return self
end

--[[--
   Remove from Map
]]
function C:removeFromMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = false
end

--[[--
   Add to Map
]]
function C:addToMap()
   map.objects[map:indexOf(self.pos[1], self.pos[2])] = self
end
return {
   axis=horizontal,
   children={
	  {size={200,"dp"},
	   axis=vertical,
	   children={
		  {class=UIButton,
		   name="info",
		   text="testing",
		   color="000000cc",
		   size={1,"w"}},
		  {class=UIList,
		   axis = vertical,
		   name = "actions",
		   size={100,"dp"}}
	   }},
	  {size={1,"w"},
	   axis=vertical,
	   children={
		  {class=UIButton,
		   name="money",
		   text="$yeet",
		   color="00ff00",
		   size={30,"sp"}},
	  }},
   }
}
require("util")
local isMain = Util.isMain()
require("ui/UIElement")
require("ui/ListButton")
require("level-select/load")
require("viewer/load")
require("world/load")
require("dialogue/overlay")
DragableTest = {}
local D = DragableTest

--[[
   click button

   @param x 
   @param y 
]]
function DragableTest.MouseDown(x,y)
   local d = D.dragables:which(x,y)
   if d then
      d:start(x,y)
   end
end

--[[
   resize

   @param w 
   @param h 
]]
function DragableTest.Resize(w,h)
   Util.Resize(w,h)
   UIElement.recalc(D.scene)
   D.dragables:resize()
end

--[[--
   Basic menu setup
]]
function DragableTest.Start()
   D.scene = {{s="screen",c={{s="drag", d={i=0}},{s="drag", d={i=1}},{s="drag", d={i=2}}}}}
   D.named, D.scene = UIElement.getNamed(
      D.scene, getStyles({"test/drawables", "screen"}))
   D.dragables:init(D.named)
end

--[[
   draw shit
]]
function DragableTest.Update()
   --Update=static.quit
   D.dragables:draw()
end

--[[
   destroy shit
]]
function DragableTest.End()
   D.dragables:destroy()
end

Util.try(isMain, D)
require("util")
Draggable = Class()

function Draggable.new(layout)
   local self = {layout=layout}
   setmetatable(self, Draggable)
   self:resize()
   return self
end

function Draggable:resize()
   self:destroy()
   self.rect = self.layout.rect()
   local r = self.rect
   self.s = Surface.newBlank(r[3], r[4])
   Surface.fill(s2, r[1],r[2],r[3],r[4], self.layout.d.i*80,250,0,255)
   self.t = Surface.textureFrom(self.s)
end

function Draggable:draw()
   local r = self.rect
   table.print(r)
   Texture.renderCopy(self.t,0,0,r[3],r[4],r[1],r[2],r[3],r[4])
end

function Draggable:which(x,y)

end

function Draggable:destroy()
   if self.s then
      Surface.destroy(self.s)
   end
   if self.t then
      Surface.destroy(self.t)
   end
end
    
    OS/2hk      `cmapbe  Y  glyf!H    Eheadmy  N   6hhea     $hmtx    N  loca "D  J   maxp ,      namef<  S  posthc                   3                 
        FSTR @  !"                         f 3                      9:       	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a                                   b c  d  e        f     g      h    j i k m l n  o q p r s u t v w  x z y { } |    ~      	
  !"#$%&'()*+,- ./0123456    7        8 UringuringnumeralsigngreeknumeralsignlowergreekypogegrammeniquestiongreekAlphaBetaGamma
DeltagreekEpsilonZetaEtaThetaIotaKappaLambdaMuNuXiOmicronPiRhoSigmaTauUpsilonPhiChiPsialphabetagammadeltaepsilonzetaetathetaiotakappalambdamugreeknuxiomicronrhosigma1sigmatauupsilonphichipsiomegaquoteleftreversedEuroglyph1glyph2                             , 
                              !533             333             5##535#533333#3###                       !5!5!#53%5!%5355353!                        553553!53553!!%53           
             # '  35!353%53!3753353%53%33353                      	  5355#5!              !53%353          3535353              733353%5!35!%3                  %!5!3!!                 	  15355#5!            5!          1!               553553553553553              35!5333#!5#5335!             353#53533         	       13!53553553%53!53%5!                  15!535!535!                   !!535335#53533#           15!53!!!                  35!53!3!!5!               !33!#!                         35!%3!35!%3!35!                            35!3!5!35!                    1!!                 	   15355#5!!                     %53%53%53553553          5!5!               753553553%53%53                !53353%53!53%5!                   35!5#37!535!                   13!53#!53353%53          %3!!!3!!                  35!%35!                %535353!!!             1!!!!!             	  1!!!!            35!!5!%35!               13!3#!           15!!5!!!              35!%3!!5!                 !53%53%535355333#53                13!            333#!#353                      5333#!#533                 35!%3!35!           3!!!!                      35!353%53%533%35!                  !33!!!#5!                       15!535!%35!                    !!5!!               35!%3!3                   !53%53353%3!3               33333!3!3          	             #  13!353353%53%53353%3!3                         !33333!3                   	     13!5355355355!5!                 3!!!               %53%53%53%53%53             35!!5!              53!53%53353%53            15!         53%5!             5535!5!5!535!              %33!!!            35!%35!              535!!5!3           35!%3!53!5!             3#5353!!5!                15!535!5!535!                !3!3!!              	   15!!5!!53                35!%3!#5!53                  !53%53535533!!                 !#5!3               !3!!###                 	  !3!!!                35!%3!35!           3!!!!                  35!5!!5!              1!!                 15!553%5!%5355!             !5!%#533!!             	  535!3                  !53%3333!3                           33333!3!3            	             #  153!53%53353%53%53353%53!53               15!35!5!3                   15353!5355!5!#         	   !33535!#            !3           	   353353%#5!                 53!3753%533                !353               !5#5!!35353!              153#5333#!5!                     553!53%5!%53!53%5!%53!53                 #  !5#535#53533#3#53353%53!53              !33              15!55!5!533!!5!            53353                  15!35!%53%5!35!5#!5#!            5#!5!5!                  753353%33353353                 5!5!             %!!           5!              53%53353%53              55!5!5!53!!            !5!5!!!             5!5!5!5!5!             5355!           13!!3         !#5#35!##              53              35!553%53           #5!            #!                553353%33353353               %!           %!!                  5!3!!                         35!%53!53%535353                    13!53#!53353%5353%5!                    13!53#!53353%535355!     	            # ' +  13!53#!53353%53%53!53%53353%53       	            # ' +  13!53#!53353%53553%53353353%53                  13!53#!53353%5353353                 #  13!53#!53353%353353%53                 1335#535!!!!!!#                5!553%5#5!!35!                 1!!!!!53%5!                  1!!!!!5355!                     13!53!!!!53353%53                      1!!!!!53353                 15!!5!!!53%5!                   15!!5!!!5355!                  15!!3!53!!53353%53                      15!!5!!!53353                %3#53!!3#!                      # '  5333#!#53353%53353353%53                      35!%3!35!53%5!                     35!%3!35!5355!      	              #  35!%3!35!%53!53%53353%53                      !  35!%3!35!5353353353%53                      35!%3!35!53353     	             #  553!53%53353%53%53353%53!53                35!5333#!#53535!                  35!%3!353%5!                   35!%3!35355!                      35!%3!353353%53                  35!%3!353353                        !33333!35355!                      33!!!!                   !5!5353%53353%5!                           5535!5!5!535!53%5!                   5535!5!5!535!5355!                     ! %  5535!5!5!535!%53!53%53353%53                    #  5535!5!5!535!5353353353%53                    5535!5!5!535!53353                   !  5535!5!5!535353353353%53                553535#5353353!!53353                 5!553%5#5!!35!                   35!%3!53!5!53%5!                      35!%3!53!5!5355!                    ! %  35!%3!53!5!%53!53%53353%53                  35!%3!53!5!53353             	    15!!5!!53%5!                	    15!!5!!5355!                    15!!3!!53%53353%53                	    15!!5!!53353                 %3#53!!3#!                     !3!!53!53353353%53                        35!%3!35!53%5!                     35!%3!35!5355!      	              #  35!%3!35!%53!53%53353%53                      !  35!%3!35!5353353353%53                      35!%3!35!53353              %535!53              535#33!5#5!5!3                 	    535!353%5!              	    535!35355!                	     535!353353%53           	    535!353353                  15!35!5!35355!                   533!!!!                15!35!5!353353                     35!%3!3              	  535!3                    !33333!353353                     5355!            35355!             !33          	   15355#5!!                     13!53#!53353%53          %3!!!3!!                1!!                13!33333                   1!!!!!              	     13!5355355355!5!                 13!3#!               35!533!35!             15!!5!!!                  !53%53%535355333#53                    13!33333                     333#!#353                      5333#!#533                15!5!5!               35!%3!35!          3#5!###              3!!!!               	     13!53553%53%!!                   !!5!!                 !33333!3                      53!53#535#5333#3#      	             #  13!353353%53%53353%3!3                       3#5333#3                153533333!35!                     35!%35!5#535#5353                33!!!!53%5!                    !353353%3!3                       35!%3!353533!!                     35!%3!!5!                !5!553%3!5355!5!!               	  !3!!!               35!%3!3#!5!             !3                !53%53533!!53                         13!353353%53%53%53              13!!3             !53%53353%3!3              !5!553%3!#5!!!                    35!%3!35!          3#5!#3!#              13!!35!                	    !5!55!5!5355!                   35!%3!!5!           !!5!!               35!%3!3                 53!535#535#53533#3#    	             #  153!53%53353%53%53353%53!53               3#5333#3                     353353%33333                5!       	  3353          	  5355#5!            	  15355#5!            	  53%!#            	    3353353353              53353%5#5!#5#                153353%5#5!#5#             #5333#                 5#!            133333                %53%353                %535353                  !5!%5#535#5353!!!!5!              1!                       (   P       l      H  x       (  @  X               D      8        ,  T      @      	  	P  	  	  	  
  
D  
|  
    P        x      4  h       x      <          ,  l        L        8  |      ,  X        ,  p      (  x    (  h        H  p      `      @  d      X  x        4  d          8  h        $  P      D    0             !(  !p  !  "  "X  "  "  #@  #  #  $L  $  %   %|  %  &H  &  '  'd  '  (  (T  (  (  )d  )  *  *  *  +T  +  ,  ,h  ,  -  -  -  .0  .p  .  /  /P  /  0  0d  0  1T  1  1  20  2t  2  3  3D  3  3  40  4d  4  4  5  5@  5\  5  5  6$  6D  6  6  7  7@  7  7  8(  8x  8  9  9@  9  9  9  :<  :`  :  ;  ;|  ;  <  <h  <  =  =h  =  =  >(  >p  >  >  ?D  ?t  ?  @  @P  @  @  A  A<  A`  A  A  BT  B  B  B  C$  CL  Ct  C  C  D  DT  D  D  D  E  ED  E  E      cN_<          y                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             n        K         
 K        U        \       
 o        y               <               	        
 )               0(       (X       .       )  	     	  m  	    	  &  	    	  8  	    	  x  	  *  	 	   	 
 J  	  P  	  \e  	  zCreated by total FontGeek, generated by FontStruct. Licensed under CC BY SAMozart NBPRegularFontStruct Pixel 01Mozart NBPVersion 1.0Pixel-01FontStruct is a trademark of FSI FontShop International GmbHhttp://fontstruct.comNate HalleyPixel 01 was built with FontStruct
http://www.fontshop.comhttp://fontstruct.com/fontstructions/show/924893Creative Commons Attribution Share Alikehttp://creativecommons.org/licenses/by-sa/3.0/Five big quacking zephyrs jolt my wax bed C r e a t e d   b y   t o t a l   F o n t G e e k ,   g e n e r a t e d   b y   F o n t S t r u c t .   L i c e n s e d   u n d e r   C C   B Y   S A M o z a r t   N B P R e g u l a r F o n t S t r u c t   P i x e l   0 1 M o z a r t   N B P V e r s i o n   1 . 0   ( 2 - J a n u a r y - 2 0 1 4 ) M o z a r t N B P F o n t S t r u c t   i s   a   t r a d e m a r k   o f   F S I   F o n t S h o p   I n t e r n a t i o n a l   G m b H h t t p : / / f o n t s t r u c t . c o m N a t e   H a l l e y M o z a r t   i s   p a r t   o f   t h e   N B P   C o l l e c t i o n . C r e a t i v e   C o m m o n s   A t t r i b u t i o n   S h a r e   A l i k e h t t p : / / c r e a t i v e c o m m o n s . o r g / l i c e n s e s / b y - s a / 3 . 0 / Q u i r k y   s p u d   b o y s   c a n   j a m   a f t e r   z a p p i n g   f i v e   w o r t h y   p o l y s i x e s .                             (     ~  oxuz~     " & : !"      nxtz~     " & 9 !"R  O    65.                                                   
                                                                           	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a                                    p c d h v  n j t i       q     f u          k z     b m         l {                              w                            o       x           (     ~  oxuz~     " & : !"      nxtz~     " & 9 !"R  O    65.                                                  return {"mozart.ttf","mozart_readme.txt"}MOZART NBP
made by Nate Halley
using FontStruct
Version 1.0
Date: 02 January 2014

DESCRIPTION
===========
An 8-bit BASIC interpreter-styled typeface.

LICENSE
=======
Mozart is Creative Commons (by-sa) Attribution Share Alike. That means it's free to download and use. You can also upload it to another website but only as long as you give me credit for making it. You can even make changes to it as long as you give me credit for making the first version and license your new version as CC-BY-SA too.
For more information, go to:
http://creativecommons.org/licenses/by-sa/3.0/

A REQUEST FROM NATE547
======================
Once you install this font, find 2 ways to make the world, the country, your home state/province/county, or your hometown better than it is. Even if it's just recycling your newspaper instead of tossing it on the rubbish.
Of course, you're not obligated by law to do this.... it's just a request from a Sensible Human who wants our world to change.

Duty now for the future.

Nate547 (total FontGeek)
require("util")
local isMain = Util.isMain()

--[[
   Render to texture + glitch art.

   Also a good demo of what textures can do currently
]]
function Start()
   music, err = Music.new("test.ogg")
   print(music, err)
   paused = false
   music:play(-1)
   static.framedelay(1000)
end

--[[
   draw some random colored copies
]]
function Update()
   --Update = static.quit
end

--[[
   destroy things
]]
function End()
   music:destroy()
end

function KeyDown(k)
   if k == KEY_ESCAPE then
	  static.quit()
   elseif k == KEY_SPACE then
	  paused = not paused
	  if paused then
		 music:pause()
	  else
		 music:resume()
	  end
   end
end

--purely a test class, so I used globals and then just told Util to pull off the global env instead of a class
Util.try(isMain, _G)
return {
   load="test/surface/surface-tests.lua",
   doInitSDL=true,
}
require("util")
local isMain = Util.isMain()

--[[
   Draws an image with a colored background

   Demo of what surfaces can do
]]
function Start()
   print("hi")
   s = Surface.new("images/headsprites.png")
   w,h = Surface.size(s)
   s2 = Surface.newBlank(w, h)
   Surface.fill(s2, 56,56,56,56
				,250,250,0,255)
   Surface.fill(s2, 56 * 2,0,56,56
				,0,200,200,255)
   Surface.blit(s2, s, 0, 0)
   t = Surface.textureFrom(s)
   t2 = Surface.textureFrom(s2)
   spr = Sprite.new(t, 0,0,w,h,0,0)
   spr2 = Sprite.new(t2, 0,0,w,h,0,0)
   sprs = {spr, spr2}
   ts = {t, t2}
   Surface.destroy(s2)
   Surface.destroy(s)
   static.framedelay(1000//30)
end

--[[
   draw things
]]
function Update()
   --Update = static.quit
   for i, spr in ipairs(sprs) do
	  spr:draw(0,h * (i - 1))
   end
end

--[[
   destroy things
]]
function End()
   for i, t in ipairs(ts) do
	  Texture.destroy(t)
   end
   for i, spr in ipairs(sprs) do
	  spr:destroy()
   end
   print("goodbye")
end

--purely a test class, so I used globals and then just told Util to pull off the global env instead of a class
Util.try(isMain, _G)
require("util")
local isMain = Util.isMain()

--[[
   Render to texture + glitch art.

   Also a good demo of what textures can do currently
]]
function Start()
   t,w,h = Texture.new("images/headsprites.png")
   static.renderBlendmode(BLENDMODE_BLEND);
   tar = Texture.newTarget(SCREEN_WIDTH, SCREEN_HEIGHT)
   Texture.blendmode(tar, BLENDMODE_BLEND)
   Texture.blendmode(t, BLENDMODE_NONE)
   static.setRenderTarget(tar)
   static.renderClear()
   for x = 0,SCREEN_WIDTH//w do
	  for y = 0,SCREEN_WIDTH//h do
		 Texture.renderCopy(t,0,0,w,h,x*w,y*h,w,h)
	  end
   end
   static.unsetRenderTarget(tar)
   static.framedelay(1000//60)
end

--[[
   draw some random colored copies
]]
function Update()
   local y = 20
   Texture.setRGBMask(tar,255,255,255)
   Texture.setAMask(tar,255)
   Texture.renderCopy(tar,0,0,SCREEN_WIDTH, SCREEN_HEIGHT,0,0,SCREEN_WIDTH, SCREEN_HEIGHT)
   makeGlitch(tar, {0,0,SCREEN_WIDTH, SCREEN_HEIGHT})
   --Update = static.quit
end

--[[
   destroy things
]]
function End()
   Texture.destroy(t)
   Texture.destroy(tar)
end

--[[
   Render one colored copy of a portion of target texture to the screen

   @param tar Texture to copy
   @param r rect size of area to copy to
]]
function makeOneGlitch(tar, r)
   local d={}
   local e={}
   local f = {}
   local minw = 5
   for i=1,2 do
	  local w = r[i+2]
	  d[i]=math.random(r[i],r[i]+w-5)
	  e[i]=math.random(r[i],r[i]+w-5)

	  d[i+2]=math.random(5,w-(d[i]-r[i]))
   end
   if math.random(1,100) > 20 then
	  d[math.random(3,4)]=minw
   end
   for i =1,4 do
	  f[i]=math.random(255,255)
   end
   for i=1,2 do
	  f[math.random(1,3)]=0
   end
   --f[4] = 255
   Texture.setRGBMask(tar,f[1],f[2],f[3])
   Texture.setAMask(tar,f[4])
   Texture.renderCopy(tar,d[1],d[2],d[3],d[4], e[1],e[2],d[3],d[4])
end

--[[
   Render many colored copy of a portion of target texture to the screen

   @param tar Texture to copy
   @param r rect size of area to copy to
]]
function makeGlitch(tar, r)
   for i = 1,20 do
	  makeOneGlitch(tar, r)
   end
end

--purely a test class, so I used globals and then just told Util to pull off the global env instead of a class
Util.try(isMain, _G)
return {
   load="test/texture/texture-tests.lua",
   doInitSDL=true,
}
DUtil = {}

--[[
Go to point

@param point 

@return callback closure
]]
function DUtil.go(point)
   return function(self)
	  self:go(self.dialogue, point)
   end
end

--[[
reload current point

@param self 
]]
function DUtil.reload(self)
   self:go(self.dialogue, self.point)
end

--[[
load a view controller in the global scope

@param name 

@return callback closure
]]
function DUtil.loadGlobalController(name)
   return function (self)
	  End()
	  Util.setController(rawget(_G, name))
	  Start(0,{})
   end
end
return {"overlay.lua","story/","test-text.lua","util.lua"}require("util")
local isMain = Util.isMain()
require("flex/flex")
Dialogue = Class()
Dialogue.bHeight = 60
Dialogue.bSpace = 10
local D = Dialogue

--[[--
   Dialogue - basic ui for textual interactions with the story,
   other npcs and such

   @param dialogue Tree of currently loaded dialogue
   @param point Entry point into `dialogue` tree

   @return new boy
]]
function Dialogue.new(dialogue, point)
   local self = New(D)
   self.cells = Flex.load("dialogue/layout.lua")
   local named = Flex.getNamed(self.cells.children)
   named.actions.size[1] = ListButton.heightOf(3, self.bHeight, self.bSpace) + self.bSpace + self.bHeight // 2
   self.rects = Flex.calculateRects(self.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   self.views = Flex.new(self.cells, self.rects)
   self.named = Flex.getNamed(self.views)
   self:setButtons({}, {})

   self:go(dialogue, point)
   return self
end

function Dialogue:setButtons(fns, texts)
   ListButton.init(self.named.actions,
				   fns,
				   texts,
				   self.bHeight,
				   self.bSpace,
				   self)
end

--[[--
   fetches the text from a dialogue at a point

   @return text
]]
function Dialogue:fetchText()
   return self.dialogue[self.point].text
end

--[[--
   fetches the point's node from a dialogue

   @return node {text=,buttons={fns=,texts=}}
]]
function Dialogue:fetch()
   return self.dialogue[self.point]
end

--[[--
   go to the next bit of unread text
   if all text is read, display the current dialogue node's buttons
]]
function Dialogue:next(b, c)
   self.named.actions:moveTo(0, 0)
   if self.named.textbox:next() then
	  local buttons = self:fetch().buttons
	  if buttons then
		 self:setButtons(buttons.fns, buttons.texts)
	  end
   end
end

--[[
Goes to a dialogue/point pair, loads dialogue

@param dialogue 
@param point 
]]
function Dialogue:go(dialogue, point)
   self.named.actions:moveTo(0, 0)
   self.dialogue = dialogue
   self.point = point
   self.named.textbox:setText(self:fetchText())
   self:setButtons({self.next},{"Next"})
end

--[[--
   draw the dialogue
]]
function Dialogue:draw()
   Flex.draw(self.views)
end

--[[
click on button

@param x 
@param y 

@return whether any button was clicked
]]
function Dialogue:click(x,y)
   return Flex.click({x, y}, self.views, self.rects)
end

--[[--
   resize that boy
]]
function Dialogue:resize()
   self.rects = Flex.calculateRects(self.cells, {0,0,SCREEN_WIDTH,SCREEN_HEIGHT})
   Flex.setRects(self.views, self.rects)
end

--[[--
   destroy the boy
]]
function Dialogue:destroy()
   Flex.destroy(self.views)
   self.rects = nil
   self.views = nil
   self.named = nil
   self.cells = nil
   self.point = nil
   self.dialogue = nil
end

--[[
open a dialogue file

@param name 

@return contents
]]
function Dialogue.open(name)
   return dofile("dialogue/story/"..name..".lua")
end

--[[
   start
]]
function Dialogue.Start()
   D.test = Dialogue.new(Dialogue.open("test"), "main-entry")
end

--[[
   standard Flex mouse down

   @param x 
   @param y 
]]
function Dialogue.MouseDown(x,y)
   Flex.mouseDown(D.test, x, y)
end

--[[
   standard Flex mouse move

   @param x 
   @param y 
]]
function Dialogue.MouseMove(x,y)
   Flex.mouseMove(D.test, x, y)
end

function Dialogue.MouseWheel(x,y,dx,dy)
   Flex.mouseWheel(D.test, x, y, dx, dy)
end

--[[
   standard Flex mouse up

   @param x 
   @param y 
]]
function Dialogue.MouseUp(x,y)
   Flex.mouseUp(D.test, x, y)
end

--[[
   updato
]]
function Dialogue.Update()
   --Update=static.quit
   D.test:draw()
end

--[[
   resizando

   @param w 
   @param h 
]]
function Dialogue.Resize(w,h)
   SCREEN_WIDTH, SCREEN_HEIGHT = w,h
   local x = D.test
   D.test:resize()
end

--[[
   end
]]
function Dialogue.End()
   D.test:destroy()
   D.test = nil
end

Util.try(isMain, D)
return "this is the story of a girl, who cried a river and drowned the whole world, but while she looked so sad and lonely there, I absolutely love her - when she smiled. How many days in the year, she woke up with hope but she only found tears, and how did I end up this way - making her promises never for real"
return {
   axis=vertical,
   children={
	  {class=UITextBox,
		   name="textbox",
		   text="testing",
		   bg="ff0000",
		   size={1,"w"}},
	  {class=UIList,
	   axis = vertical,
	   name = "actions",
	   size={100,"dp"}},
   },
}
require("dialogue/util")

return {
   ["main-entry"]={
	  text="Each dialogue has its own text field. This is all the text that is displayed before a choice. Then the choices are presented. Choice functions take a first argument of the Dialogue element that is currently displaying them.",
	  buttons={
		 texts={"reshow that message", "go to another dialogue bit","Main Menu"},
		 fns={DUtil.reload, DUtil.go("second"), DUtil.loadGlobalController("MainMenu")}
	  }
   },
   second={
	  text="That's it! you visited a new piece of dialogue",
	  buttons={
		 texts={"back to main topic"},
		 fns={DUtil.go("main-entry")}
	  }
   }
}
return {"fakes.lua","static.lua"}UpdateStack = {}

function uloadfile(fname, mode, env)
   local mod = Game.static.readfile(fname)
   local x = load(mod, fname, mode, env)
   if x then
      x = x()
   end
   return x
end

--[[--
   indexing checks metatable first
   and falls back to object if that fails

   @param mt metatable
]]
function metareplacer(mt)
   return function(t, f)
      v = rawget(t, f)
      if v ~= nil then
		 return v
      end
      return rawget(mt, f)
   end
end

--[[--
   metareplaces t

   @param t table
]]
function meta(t)
   t.__index = metareplacer(t)
end

--[[--
   creates a new already metareplaced object ready to become a class

   @return new class table
]]
function Class()
   local t = {}
   meta(t)
   return t
end

--[[--
   creates a new already metareplaced instance
   
   @param class Class to create an instance of
]]
function New(class)
   self = {}
   setmetatable(self, class)
   return self
end

--[[--
   make everything in x global

   @param x table
]]
function makeGlobal(x)
   for k,v in pairs(x) do
      rawset(_G, k, v)
   end
end

--[[--
   list everything in dir, hack cause neither lua nor C supported it. C++ probably has a better solution.
   
   @param path 

   @return contents
]]
function listdir(path)
   return dofile(path .. "contents.lua")
end

--[[--
   copy a table

   @param t table to copy

   @return new table
]]
function table.copy(t)
   local n = {}
   for k, v in pairs(t) do
	  rawset(n, k, v)
   end
   return n
end

--[[
   DONT USE see math.min

   @deprecated
   @private

   @param x 
   @param y 

   @return
]]
function min(x,y)
   if x < y then
	  return x
   end
   return y
end

--[[
   DONT USE see math.max

   @deprecated
   @private

   @param x 
   @param y 

   @return
]]
function max(x,y)
   if x < y then
	  return y
   end
   return x
end

--[[
   merge 2 tables

   @param dst destination
   @param src source
]]
function merge(dst,src)
   for k,v in pairs(src) do
	  dst[k] = v
   end
end

--[[--
   prints out a table

   @param t table to print
]]
function table.print(t)
   if type(t) ~= "table" then
	  print(t)
	  return
   end
   print("__#__", #t)
   for k,v in pairs(t) do
	  print(k,v)
   end
end

--[[
desc.

@param t 
@param fn 

@return
]]
function table.map(t, fn)
   local t2 = {}
   for k,v in pairs(t) do
	  t2[k] = fn(k,v)
   end
   return t2
end

if Game then makeGlobal(Game) end
require("util/static")
function Fake()
   local mt = {}
   mt.__index = function(t, f)
      v = rawget(t, f)
      if v ~= nil then
		 return v
      end
	  v = rawget(mt, f)
      if v ~= nil then
		 return v
      end
      return function () end
   end
   return mt
end

TTF = Fake()
Surface = Fake()
function TTF.size(x)
   return #x
end

return {"large-boi-test.lua","money-goal-test.lua","spawner-test.lua","test.lua"}return {
  version = "1.1",
  luaversion = "5.1",
  tiledversion = "1.1.5",
  orientation = "orthogonal",
  renderorder = "right-down",
  width = 13,
  height = 13,
  tilewidth = 32,
  tileheight = 32,
  nextobjectid = 21,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      filename = "tiles.tsx",
      tilewidth = 32,
      tileheight = 32,
      spacing = 0,
      margin = 0,
      image = "tiles.png",
      imagewidth = 96,
      imageheight = 64,
      tileoffset = {
        x = 0,
        y = 0
      },
      grid = {
        orientation = "orthogonal",
        width = 32,
        height = 32
      },
      properties = {},
      terrains = {},
      tilecount = 6,
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "Tile Layer 1",
      x = 0,
      y = 0,
      width = 13,
      height = 13,
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      properties = {},
      encoding = "lua",
      data = {
        3, 6, 3, 3, 3, 6, 6, 6, 3, 3, 3, 6, 3,
        6, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 3, 6,
        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
        3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3,
        3, 6, 6, 6, 3, 6, 3, 6, 3, 6, 6, 6, 3,
        3, 6, 6, 6, 3, 3, 3, 3, 3, 6, 6, 6, 3,
        3, 6, 6, 6, 3, 6, 3, 6, 3, 6, 6, 6, 3,
        3, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3,
        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
        6, 3, 0, 0, 0, 3, 3, 3, 0, 0, 0, 3, 6,
        3, 6, 3, 3, 3, 6, 6, 6, 3, 3, 3, 6, 3
      }
    },
    {
      type = "objectgroup",
      name = "slug",
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      draworder = "topdown",
      properties = {},
      objects = {
        {
          id = 3,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 144,
          y = 147,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 1
          }
        },
        {
          id = 13,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 176,
          y = 146,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 17,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 181,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 18,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 211,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 2
          }
        },
        {
          id = 19,
          name = "spawner",
          type = "spawner",
          shape = "point",
          x = 209,
          y = 19,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
			 ["index"] = 1,
            ["spawner"] = true
          }
        },
        {
          id = 20,
          name = "spawner",
          type = "spawner",
          shape = "point",
          x = 209,
          y = 402,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2,
            ["spawner"] = true
          }
        }
      }
    }
  }
}
return {
  version = "1.1",
  luaversion = "5.1",
  tiledversion = "1.1.5",
  orientation = "orthogonal",
  renderorder = "right-down",
  width = 13,
  height = 13,
  tilewidth = 32,
  tileheight = 32,
  nextobjectid = 19,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      filename = "tiles.tsx",
      tilewidth = 32,
      tileheight = 32,
      spacing = 0,
      margin = 0,
      image = "tiles.png",
      imagewidth = 96,
      imageheight = 64,
      tileoffset = {
        x = 0,
        y = 0
      },
      grid = {
        orientation = "orthogonal",
        width = 32,
        height = 32
      },
      properties = {},
      terrains = {},
      tilecount = 6,
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "Tile Layer 1",
      x = 0,
      y = 0,
      width = 13,
      height = 13,
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0,
        0, 0, 3, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0,
        0, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 0,
        0, 0, 3, 3, 3, 3, 3, 0, 3, 0, 0, 6, 0,
        0, 0, 0, 3, 3, 3, 3, 3, 3, 6, 6, 6, 0,
        0, 0, 3, 3, 3, 3, 3, 0, 0, 6, 6, 0, 0,
        0, 3, 3, 3, 0, 0, 3, 6, 6, 6, 6, 6, 0,
        0, 3, 3, 3, 3, 3, 0, 6, 0, 0, 0, 0, 0,
        0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "slug",
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      draworder = "topdown",
      properties = {},
      objects = {
        {
          id = 3,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 144,
          y = 147,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 1
          }
        },
        {
          id = 13,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 176,
          y = 146,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 14,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 177,
          y = 180,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 3
          }
        },
        {
          id = 15,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 175,
          y = 212,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 4
          }
        },
        {
          id = 16,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 207,
          y = 208,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 5
          }
        },
        {
          id = 17,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 181,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 18,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 211,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 2
          }
        }
      }
    }
  }
}
return {
  version = "1.2",
  luaversion = "5.1",
  tiledversion = "1.2.1",
  orientation = "orthogonal",
  renderorder = "right-down",
  width = 13,
  height = 13,
  tilewidth = 32,
  tileheight = 32,
  nextlayerid = 4,
  nextobjectid = 21,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      filename = "tiles.tsx",
      tilewidth = 32,
      tileheight = 32,
      spacing = 0,
      margin = 0,
      columns = 3,
      image = "tiles.png",
      imagewidth = 96,
      imageheight = 64,
      tileoffset = {
        x = 0,
        y = 0
      },
      grid = {
        orientation = "orthogonal",
        width = 32,
        height = 32
      },
      properties = {},
      terrains = {},
      tilecount = 6,
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      id = 1,
      name = "Tile Layer 1",
      x = 0,
      y = 0,
      width = 13,
      height = 13,
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0,
        0, 0, 3, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0,
        0, 3, 3, 3, 3, 3, 3, 3, 3, 6, 6, 6, 0,
        0, 0, 3, 3, 3, 3, 3, 0, 3, 0, 0, 6, 0,
        0, 0, 0, 3, 3, 3, 3, 3, 3, 6, 6, 6, 0,
        0, 0, 3, 3, 3, 3, 3, 0, 0, 6, 6, 0, 0,
        0, 3, 3, 3, 0, 0, 3, 6, 6, 6, 6, 6, 0,
        0, 3, 3, 3, 3, 3, 0, 6, 0, 0, 0, 0, 0,
        0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      id = 2,
      name = "slug",
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      draworder = "topdown",
      properties = {},
      objects = {
        {
          id = 3,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 144,
          y = 147,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 1
          }
        },
        {
          id = 13,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 176,
          y = 146,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 14,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 177,
          y = 180,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 3
          }
        },
        {
          id = 15,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 175,
          y = 212,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 4
          }
        },
        {
          id = 16,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 207,
          y = 208,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 5
          }
        },
        {
          id = 17,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 181,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 18,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 337,
          y = 211,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 2
          }
        }
      }
    },
    {
      type = "objectgroup",
      id = 3,
      name = "objects",
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      draworder = "topdown",
      properties = {},
      objects = {
        {
          id = 19,
          name = "50$",
          type = "money",
          shape = "point",
          x = 112,
          y = 209,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["value"] = 50
          }
        },
        {
          id = 20,
          name = "goal",
          type = "goal",
          shape = "point",
          x = 77,
          y = 272,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
return {
  version = "1.1",
  luaversion = "5.1",
  tiledversion = "1.1.5",
  orientation = "orthogonal",
  renderorder = "right-down",
  width = 100,
  height = 100,
  tilewidth = 32,
  tileheight = 32,
  nextobjectid = 21,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      filename = "tiles.tsx",
      tilewidth = 32,
      tileheight = 32,
      spacing = 0,
      margin = 0,
      image = "tiles.png",
      imagewidth = 96,
      imageheight = 64,
      tileoffset = {
        x = 0,
        y = 0
      },
      grid = {
        orientation = "orthogonal",
        width = 32,
        height = 32
      },
      properties = {},
      terrains = {},
      tilecount = 6,
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "Tile Layer 1",
      x = 0,
      y = 0,
      width = 100,
      height = 100,
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      properties = {},
      encoding = "lua",
      data = {
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 3, 3, 3, 6, 6, 6, 3, 3, 3, 6, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 1, 1, 1, 3, 3, 3, 1, 1, 1, 3, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 6, 6, 3, 6, 3, 6, 3, 6, 6, 6, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 6, 6, 3, 3, 3, 3, 3, 6, 6, 6, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 6, 6, 3, 6, 3, 6, 3, 6, 6, 6, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 3, 1, 1, 1, 3, 3, 3, 1, 1, 1, 3, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 6, 3, 3, 3, 6, 6, 6, 3, 3, 3, 6, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
      }
    },
    {
      type = "objectgroup",
      name = "slug",
      visible = true,
      opacity = 1,
      offsetx = 0,
      offsety = 0,
      draworder = "topdown",
      properties = {},
      objects = {
        {
          id = 3,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 1552,
          y = 1523,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 1
          }
        },
        {
          id = 13,
          name = "Slug1",
          type = "test",
          shape = "point",
          x = 1584,
          y = 1522,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 17,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 1745,
          y = 1557,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2
          }
        },
        {
          id = 18,
          name = "Slug2",
          type = "test2",
          shape = "point",
          x = 1745,
          y = 1587,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["team"] = 2
          }
        },
        {
          id = 19,
          name = "spawner",
          type = "spawner",
          shape = "point",
          x = 1617,
          y = 1395,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 1,
            ["spawner"] = true
          }
        },
        {
          id = 20,
          name = "spawner",
          type = "spawner",
          shape = "point",
          x = 1617,
          y = 1778,
          width = 0,
          height = 0,
          rotation = 0,
          visible = true,
          properties = {
            ["index"] = 2,
            ["spawner"] = true
          }
        }
      }
    }
  }
}
return {
   version = "1.2",
   luaversion = "5.1",
   tiledversion = "1.2.1",
   name = "collectables",
   tilewidth = 32,
   tileheight = 32,
   spacing = 0,
   margin = 0,
   columns = 2,
   image = "collectables.png",
   imagewidth = 64,
   imageheight = 64,
   tileoffset = {
      x = 0,
      y = 0
   },
   grid = {
      orientation = "orthogonal",
      width = 32,
      height = 32
   },
   properties = {},
   terrains = {},
   tilecount = 4,
   tiles = {
      {
	 id = 0,
	 type = "money"
      },
      {
	 id = 1,
	 type = "goal"
      }
   }
}
return {"collectables.lua"}return {
  version = "1.2",
  luaversion = "5.1",
  tiledversion = "1.2.1",
  name = "collectables",
  tilewidth = 32,
  tileheight = 32,
  spacing = 0,
  margin = 0,
  columns = 2,
  image = "collectables.png",
  imagewidth = 64,
  imageheight = 64,
  tileoffset = {
    x = 0,
    y = 0
  },
  grid = {
    orientation = "orthogonal",
    width = 32,
    height = 32
  },
  properties = {},
  terrains = {},
  tilecount = 4,
  tiles = {
    {
      id = 0,
      type = "money"
    },
    {
      id = 1,
      type = "goal"
    }
  }
}
require("ui/TextBox")

MoneyUI = {}

function MoneyUI.get(named)
      return TextBox.new({text="0$", layout=named.money})
end
return {"object.lua","ui.lua"}require("ui/TextBox")

MoneyUI = {}
local M = MoneyUI

function MoneyUI.new(named)
   local t = named.money
   t.set = M.set
   return t
end

function MoneyUI:set(x)
   self:setData({text=tostring(x) .. "$"})
end
require("util")
require("battle/collectable")

MoneyObject = {}
Collectable.types.money = MoneyObject

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
]]
function MoneyObject.new (spr, pos, value)
   local item = Collectable.new(spr, pos, MoneyObject.take)
   item.value = value
   return item
end

--[[--
   spawn a new money object from a tiled object
   @param v a tiled object
   @param v.properties.value money item will impart on capture
   @param pos now owned by segment
]]
function MoneyObject.spawn (v, pos)
   return MoneyObject.new(Collectable.sheet.named.money, pos, v.properties.value)
end

--[[--
   called to capture the money for a player/slug
   @param player player that took money
   @param slug slug that took money
]]
function MoneyObject:take(slug)
   player.money:add(self.value)
end
require("util")
require("battle/collectable")

--[[--
   creates a new money object
   @param spr sprite
   @param pos now owned by segment
   @param value money the object will impart on capture
]]
function M.new (spr, pos, value)
   return Collectable.new(spr, pos, value, M.take)
end

--[[--
   called to capture the money for a player/slug
   @param player player that took money
   @param slug slug that took money
]]
function M:take(player, slug)
   self:removeFromMap()
   player.money:add(self.value)
end
return {"tilesets.lua"}require("util")
Tileset = Class()

--[[--
   find tile index `dat`
   @param dat
   @return false or `sheet index`, `position in sheet`
]]
function Tileset:tilefinder(dat)
   local j = 1
   if dat <= 0 then
	  return false
   end
   while dat > self[j].tilecount do
	  dat = dat - self[j].tilecount
	  j = j + 1
   end
   return j, dat
end

--[[--
   destroy
]]
function Tileset:destroyTilesets()
   for i, v in ipairs(self) do
	  if v.surface then
		 Surface.destroy(v.surface)
	  end
	  if v.sheet then
		 Texture.destroy(v.sheet)
	  end
   end
end

--[[--
   parse a hex color
   
   @param color 
   
   @return array version of color
]]
function parseColor(color)
   local l = #color
   local t = l // 6-- 0 if 3-4, 1 if 6-8
   local i = 1
   local r = tonumber(string.sub(color, i,i+t), 16)
   i = i + 1 + t
   local g = tonumber(string.sub(color, i,i+t), 16)
   i = i + 1 + t
   local b = tonumber(string.sub(color, i,i+t), 16)
   i = i + 1 + t
   if l == 8 or l == 4 then
	  a = tonumber(string.sub(color, i,i+t), 16)
   else
	  a = 255
   end
   return r,g,b,a
end

--[[--
   init a tile

   @param set 
   @param dat 
   
   @return new Tile
]]
function Tileset:initTile(set, dat)
   local tex = {}
   tex.tex = set.sheet
   tex.w = set.tilewidth
   tex.h = set.tileheight
   tex.x = ((dat - 1) % set.w) * (tex.w + set.spacing) + set.margin
   tex.y = ((dat - 1) // set.w) * (tex.h + set.spacing) + set.margin
   return tex
end

--[[--
   Loads a tileset from a named sheet resource
   @param name sheets/<name>.lua
]]
function Tileset.fromSheet(name)
   local sheet = {
      name=name,
      dofile("sheets/"..name..".lua")
   }
   Tileset.loadSurfaces(sheet)
   sheet:asTextures()
   sheet:loadTilesets()
   return sheet
end

--[[--
   load own surfaces
]]
function Tileset.loadSurfaces(self)
   self.named = {}
   setmetatable(self, Tileset)
   for i, v in ipairs(self) do
	  v.w = v.imagewidth // v.tilewidth
	  v.h = v.imageheight // v.tileheight
	  if v.tiles[1].properties and v.tiles[1].properties.color then
		 local s = Surface.newBlank(v.imagewidth, v.imageheight)
		 Surface.blendmode(s, BLENDMODE_BLEND)
		 --Surface.fill(s,0,0,200,200,255,0,255,255)
		 for i, t in ipairs(v.tiles) do
			local r,g,b,a = parseColor(t.properties.color)
			Surface.fill(s,((i - 1) % v.w) * v.tilewidth,
						 ((i - 1) // v.w) * v.tileheight,
						 v.tilewidth,
						 v.tileheight,
						 r,g,b,a)
		 end
		 local s2 = Surface.new("images/" .. v.image)
		 Surface.blit(s, s2, 0, 0)
		 Surface.destroy(s2)
		 s2 = nil
		 if v.tilewidth ~= map.tilesize then
			local w = v.w * map.tilesize
			local h = v.h * map.tilesize
			s2 = Surface.newBlank(w,h)
			Surface.blendmode(s2, BLENDMODE_BLEND)
			Surface.blendmode(s, BLENDMODE_NONE)
			Surface.blitScale(s2, s, 0,0,v.imagewidth, v.imageheight,0,0,w,h)
			--Surface.blit(s2, s, 0, 0)
			Surface.destroy(s)
			s = s2
			v.tilewidth = map.tilesize
			v.tileheight = map.tilesize
			v.imagewidth = w
			v.imageheight = h
		 end
		 v.surface = s
		 --v.sheet = Surface.textureFrom(s)
		 --Surface.destroy(s)
	  else
		 v.surface = Surface.new("images/" .. v.image)
		 --v.sheet = t
	  end
   end
end

--[[
   create the color bridges for a sheet w/colors
]]
function Tileset:colorBridge()
   local sep = map.tilesep
   for i, v in ipairs(self) do
	  if v.tiles[1].properties.color then
		 v.spacing = sep
		 v.margin = sep
		 local w = v.w + 1
		 local h = v.h + 1
		 local s = Surface.newBlank(v.imagewidth + sep * w, v.imageheight + sep * h)
		 Surface.blendmode(s, BLENDMODE_BLEND)
		 for i, t in ipairs(v.tiles) do
			local r,g,b,a = parseColor(t.properties.color)
			local x = ((i - 1) % v.w) * (v.tilewidth + sep) + sep
			local y = ((i - 1) // v.w) * (v.tileheight + sep) + sep
			local ox = ((i - 1) % v.w) * (v.tilewidth)
			local oy = ((i - 1) // v.w) * (v.tileheight)
			local sep2 = sep // 2
			local sep4 = 4
			Surface.fill(s, x - sep2, y + sep4, sep2, v.tileheight - sep4*2,r,g,b,a)
			Surface.fill(s, x + sep4, y - sep2, v.tilewidth - sep4*2, sep2,r,g,b,a)
			Surface.fill(s, x + v.tilewidth, y + sep4, sep2, v.tileheight - sep4*2,r,g,b,a)
			Surface.fill(s, x + sep4, y + v.tileheight, v.tilewidth - sep4*2, sep2,r,g,b,a)
			Surface.blendmode(v.surface, BLENDMODE_NONE)
			Surface.blitScale(s, v.surface, ox, oy, v.tilewidth, v.tileheight, x, y, v.tilewidth, v.tileheight)
		 end
		 Surface.destroy(v.surface)
		 v.surface = s
	  end
   end
end

--[[
   surfaces to textures, destroy surfaces
]]
function Tileset:asTextures()
   for i, v in ipairs(self) do
	  v.sheet = Surface.textureFrom(v.surface)
	  Surface.destroy(v.surface)
	  v.surface = nil
   end   
end

--[[
   load all tilesets
]]
function Tileset:loadTilesets()
   local k = 1
   for i, v in ipairs(self) do
	  if v.tiles[1].type and #v.tiles[1].type then
		 for j, t in ipairs(v.tiles) do
			if t.type then
			   self.named[t.type] = self:initTile(v, k)
			end
			k = k + 1
		 end
	  end
   end
end

return {"save.lua","static/"}do
   local function str(x)
      local t = type(x)
      if t == "table" then
	 return table.tostring(x)
      elseif t == "string" then
	 return string.format("%q", x)
      else
	 return tostring(x)
      end
   end

   function table.tostring(tbl)
      local data = {"{"}
      local len = #tbl
      local c = false --do comma
      for i = 1,len do
	 if c then
	    table.insert(data,",")
	 end
	 c = true
	 table.insert(data,str(tbl[i]))
      end
      local t 
      for k,v in pairs(tbl) do
	 t = type(k)
	 if t == "number" then
	    if k < 1 or k > len or k ~= k // 1 then
	       if c then
		  table.insert(data,",")
	       end
	       c = true
	       table.insert(data,"["..tostring(k).."]=")
	       table.insert(data,str(v))
	    end
	 elseif t == "string" then
	    if c then
	       table.insert(data,",")
	    end
	    c = true
	    table.insert(data,"["..string.format("%q", k).."]=")
	    table.insert(data,str(v))
	 else
	    if c then
	       table.insert(data,",")
	    end
	    c = true
	    table.insert(data,"["..tostring(k).."]=")
	    table.insert(data,str(v))
	 end
      end
      table.insert(data, "}")
      return table.concat(data)
   end
end
if not Start then
   function Start()
      file = io.open("asdf.lua","wb")
      file:write("return " .. table.tostring({nil,true,false,2,"3",a={["as\n\r\tdf"]=12,b={"bolb", c={"cat",d={"dog",e="egg"}}}},[0]=1234,[0.4]=0.3}))
      file:close()
   end
end
return {
   slugs={{["type"]="test2", number=1}, {["type"]="test", number=2}}
}
require("util")
require("tiled/tilesets")
Sector=Class()
local S = Sector
Sector.speed = 10


--[[--
   A sector is basically all the content that can be viewed at once in
   the world map. A rectangular area. Scrollable and such

   @param data data of the sector

   @return new sector
]]
function Sector.new(data)
   local self = {}
   self.data = data
   self.sprites = {}
   self.x = 0
   self.y = 0
   self.dx = 0
   self.dy = 0
   self.width = self.data.width
   self.height = self.data.height
   self.tiles = self.data.tilesets
   setmetatable(self, Sector)
   self:load()
   self:recenter()
   return self
end

--[[--
   recenter the map in the display
]]
function Sector:recenter()
   self.x = (SCREEN_WIDTH - self.width)//2
   self.y = (SCREEN_HEIGHT - self.height)//2
end


--[[--
   pan map
]]
function Sector:update()
   self.x = self.x - self.dx
   self.y = self.y - self.dy
end

--[[--
   load a sector's textures and sprites
]]
function Sector:load()
   local t = self.tiles
   Tileset.loadSurfaces(t)
   t:asTextures()
   t:loadTilesets()
   for i,o in ipairs(self.data.objects) do
	  local tile = t.named[o.tile]
	  table.insert(self.sprites, Sprite.new(tile.tex, o.x - tile.w//2, o.y - tile.h//2, tile.w, tile.h, tile.x, tile.y))
   end
end

--[[--
   draw the boy
]]
function Sector:draw()
   for i,s in ipairs(self.sprites) do
	  s:draw(self.x,self.y)
   end
end

--[[--
   destroy the boy
]]
function Sector:destroy()
   for i,s in ipairs(self.sprites) do
	  s:destroy()
   end
   self.tiles:destroyTilesets()
   self.data = nil
   self.tiles = nil
end
return {"Sector.lua","load.lua","sectors/"}require "util"
local isMain = Util.isMain()
require "world/Sector"
require "tiled/tilesets"
World = {}
local W = World
--[[--
   Load a sector of the world map.

   @param argv[2] name of sector
]]
function World.Start(argc, argv)
   framedelay = 1000//60
   local name = argv[2]
   if name == nil then
	  name = "main"
   end
   static.framedelay(framedelay)
   W.sector = Sector.new(dofile("world/sectors/"..name..".lua"))
end

--[[
   resize things

   @param w 
   @param h 
]]
function World.Resize(w, h)
   SCREEN_WIDTH = w
   SCREEN_HEIGHT = h
   W.sector:recenter()
end

--[[--
   draw things, update map
]]
function World.Update()
   --Update = static.quit
   W.sector:update()
   W.sector:draw()
end

--[[
   destroy things
]]
function World.End()
   W.sector:destroy()
   W.sector = nil
end

--[[--
   pan camera about map or quit

   @param key 
]]
function World.KeyDown(key)
   if key == KEY_ESCAPE then
	  static.quit()
   elseif key == KEY_UP then
	  W.sector.dy = -W.sector.speed
   elseif key == KEY_DOWN then
	  W.sector.dy = W.sector.speed
   elseif key == KEY_LEFT then
	  W.sector.dx = -W.sector.speed
   elseif key == KEY_RIGHT then
	  W.sector.dx = W.sector.speed
   end
end

--[[--
   Stop panning or quit

   @param key 
]]
function World.KeyUp(key)
   if key == KEY_ESCAPE then
	  static.quit()
   elseif key == KEY_UP and W.sector.dy < 0 then
	  W.sector.dy = 0
   elseif key == KEY_DOWN and W.sector.dy > 0 then
	  W.sector.dy = 0
   elseif key == KEY_LEFT and W.sector.dx < 0 then
	  W.sector.dx = 0
   elseif key == KEY_RIGHT and W.sector.dx > 0 then
	  W.sector.dx = 0
   end
end

--[[
   Trigger movement/attack or whatever other action is currently active

   @param x 
   @param y 

   @return
]]
function World.MouseDown(x, y)

end

Util.try(isMain, World)
return {
   objects={
	  {
		 name="Object A",
		 tile="testbuilding",
		 x=250,
		 y=250
	  },
	  {
		 name="Bobject",
		 tile="testbuilding",
		 x=150,
		 y=250
	  },
	  {
		 name="Cornject",
		 tile="testbuilding",
		 x=350,
		 y=350
	  },
	  {
		 name="Object D",
		 tile="testbuilding",
		 x=250,
		 y=150
	  },
   },
   width = 500,
   height = 500,
   tilesets={
	  {
		 name = "sector-main",
		 tilewidth = 100,
		 tileheight = 100,
		 spacing = 0,
		 margin = 0,
		 image = "sectors/main.png",
		 imagewidth = 100,
		 imageheight = 100,
		 tileoffset = {
			x = 0,
			y = 0
		 },
		 grid = {
			orientation = "orthogonal",
			width = 100,
			height = 100
		 },
		 properties = {},
		 terrains = {},
		 tilecount = 1,
		 tiles = {
			{
			   id = 0,
			   type = "testbuilding"
			}
		 }
	  },
   }
}
require("util")
local isMain = Util.isMain()
require("ui/UIElement")
require("text/Text")
TextBox = Class()

--[[--
   Create a new textbox

   @param self 
   @param self.text
   @param self.layout
   @param self.layout.e
   @param self.layout.e.justify optional
   @param self.layout.e.fg optional
   @param self.layout.e.bg optional

   @return new textbox
]]
function TextBox.new(self)
   setmetatable(self, TextBox)
   local layout = self.layout
   self.j = layout.e.justify or 1
   self.fg = layout.e.fg or {255,255,255,255}
   self.bg = layout.e.bg or {0,0,0,0}
   self.direction = layout.e.direction
   self:setStart()
   return self
end

--[[--
   set boy's text

   @param text 
   @param start 
]]
function TextBox:setText(text, start)
   self.start = start or 1
   self.text = text
   self:resize()
end

--[[--
   set start position (doesn't do much yet? I forget)

   @param start 
]]
function TextBox:setStart(start)
   self.start = start or 1
   self:resize()
end

--[[
desc.

@return
]]
function TextBox:next()
   local text = self.text
   self:setStart(self.start + self.displaying)
   local ltext = #text
   if self.start > ltext then
	  self.start = ltext + 1
   end
   return self.start > ltext
end

--[[--
   resize the boy
]]
function TextBox:resize()
   self:destroy()
   self.rect = self.layout:rect()
   local r = self.rect
   local text = self.text
   if self.start > #text then
	  text = ""
   elseif self.start ~= 1 then
	  text = string.sub(text, self.start)
   end
   if self.direction == 2 then
	  local len, h = Text.charsInTextbox(
		 self.text,
		 r[3],
		 r[4],
		 2)
	  text = string.sub(text, #text - len + 1, -1)
   end
   local s, l, h = Text.textbox(
	  text,
	  self.j,
	  r[3],
	  r[4],
	  self.fg,
	  1)
   self.displaying = l
   local bg = self.bg or {255,128,128,255}
   local s2 = Surface.newBlank(r[3], r[4])
   Surface.fill(s2, 0, 0, r[3], r[4], bg[1], bg[2], bg[3], bg[4])
   Surface.blit(s2, s, 0, 0)
   self.tex = Surface.textureFrom(s2)
   self.spr = Sprite.new(self.tex, r[1], r[2], r[3], r[4], 0, 0) -- sprite
   Surface.destroy(s)
   Surface.destroy(s2)

end

--[[--
   desc.

   @return
]]
function TextBox:draw()
   self.spr:draw(0,0)
end

--[[--
   desc.

   @return
]]
function TextBox:destroy()
   if self.spr then
	  self.spr:destroy()
   end
   if self.tex then
	  Texture.destroy(self.tex)
   end
end

--[[
   start the boy's tests
]]
function TextBox.Start()
   TextBox.style = getStyle("test/textbox")
   TextBox.scene = {{s="screen",c={
						{n="box",s="box"}
				   }}}
   TextBox.named,TextBox.scene = UIElement.getNamed(TextBox.scene, TextBox.style)
   TextBox.t = TextBox.new({text="testing testing 123", layout=TextBox.named.box})
end

--[[
   draw
]]
function TextBox.Update()
   --Update = static.quit
   TextBox.t:draw()
end

--[[
   end
]]
function TextBox.End()
   TextBox.t:destroy()
end


Util.try(isMain, TextBox)
require("util/static")
require("text/Text")
Button = Class()

--[[
   which of these buttons were pressed, if any

@param buttons list of buttons
@param x 
@param y 

@return button, index (can return nil if not found)
]]
function Button.which(buttons,x,y)
   local r
   for i,b in ipairs(buttons) do
	  r = b.rect
	  if x >= r[1] and x < r[1] + r[3] and y >= r[2] and y < r[2] + r[4] then
		 return b, i
	  end
   end
end

--[[--
   creates a new button
   @param self now owned by button
]]
function Button.new (self)
   setmetatable(self, Button)
   self:resize()
   return self
end

--[[--
resize the button
]]
function Button:resize()
   self.rect = self.layout:rect()
   local r = self.rect
   local c = self.color
   local s, l, h = Text.textbox(self.text, 2, r[3], r[4], {255,255,255,255})
   local s2 = Surface.newBlank(r[3], r[4])
   Surface.fill(s2, 0, 0, r[3], r[4], c[1], c[2], c[3], c[4])
   Surface.blit(s2, s, 0, (r[4] - h) // 2)
   self:destroy()
   self.tex = Surface.textureFrom(s2)
   self.spr = Sprite.new(self.tex, r[1], r[2], r[3], r[4], 0, 0) -- sprite
   Surface.destroy(s)
   Surface.destroy(s2)
end

--[[--
draw le boy
]]
function Button:draw()
   self.spr:draw(0,0)
end

--[[--
   deallocate button
]]
function Button:destroy()
   if self.tex then
	  Texture.destroy(self.tex)
   end
   if self.spr then
	  self.spr:destroy()
   end
end
return {"Button.lua","ListButton.lua","TextBox.lua","UIElement.lua","style-writer.lua","styles/"}require("util")

UIElement = {named={}}
meta(UIElement)

--[[--
   load a style from disk

   @param name style's name

   @return said style
]]
function getStyle(name)
   return dofile("ui/styles/"..name..".style.lua")
end

--[[--
   load multiple styles

   @param names all them boye's names

   @return all dem styles as one
]]
function getStyles(names)
   local all = {}
   for i, name in ipairs(names) do
	  merge(all, getStyle(name))
   end
   return all
end

--[[--
   Creates UIElements
   Calculates their properties when loaded

   @param e Elements list to render
   @param parent parent of current element list (nil is fine)

   @return table of named entities; Array.<UIElement> generated elements
]]
function UIElement.getNamed(e,style,parent)
   UIElement.named = {}
   local scene = UIElement.fromStatic(e,style,parent)
   local named = UIElement.named
   UIElement.recalc(scene)
   return named, scene
end

--[[--
   Creates UIElements

   @param e Elements list to render
   @param parent parent of current element list (nil is fine)

   @return Array.<UIElement> generated elements
]]
function UIElement.fromStatic(e,style,parent)
   local resize
   local level = {}
   local nc
   local t
   for i, v in ipairs(e) do
	  resize = style[v.s]
	  if v.c then
		 nc = #v.c
	  else
		 nc = 0
	  end
	  t = UIElement.new(v, resize, nc, parent)
	  if nc >= 1 then
		 t.c = UIElement.fromStatic(v.c,style,t)
	  end
	  if v.n then
		 t.n = v.n
		 UIElement.named[v.n] = t
	  end
	  level[i] = t
   end
   return level
end

--[[--
   Calculates/recalcs element properties
   and subchildren

   @param e Elements list to operate on
]]
function UIElement.recalc(e)
   for k,v in ipairs(e) do
	  v:resize()
	  if v.c then
		 UIElement.recalc(v.c)
	  end
   end
end

--[[--
   Calculates/recalcs element properties

   @private

   @param v.s Style name
   @param v.d Data table
   @param resize onResize function
   @param nchildren number of children
   @param parent of elem

   @return new boy
]]
function UIElement.new(v,layout,nchildren,parent)
   if not layout then
	  print(v.s, "not found")
   end
   local self = {d=v.d,resize=layout.resize,e=layout.e,nc=nchildren,p=parent, layout=layout}
   setmetatable(self, UIElement)
   return self
end

--[[--
   creates a copy of this element with the specified data table

   @param d Data table

   @return a new boy
]]
function UIElement:copy(d)
   local c = UIElement.new({d=d}, self.layout, self.nc, self.p)
   c:resize()
   return c
end

--[[--
   Prints self and children
]]
function UIElement:print()
   print(self.n, self.x, self.y, self.w, self.h)
   if self.c then
	  for i,v in ipairs(self.c) do
		 v:print()
	  end
   end
end

--[[--
   get boy's rect
   @return {x,y,w,h}
]]
function UIElement:rect()
   return {self.x, self.y, self.w, self.h}
end
return {
   load="ui/style-writer.lua",
   doInitSDL=false
}
ListButton = {}

function ListButton.init(elem, fns, texts, height, space, context)
   space = space or 0
   height = height or 30
   local nb = #fns
   local cells = {}
   local buttons = {}
   local spacer = {size={space, "dp"}}
   local btn = {size={height,"dp"}}
   -- have to insert buttons by index due to #tbl not counting nils
   local bi = 1
   for i = 1, nb do
	  table.insert(cells, btn)
	  local b = UIButton.new({context=context})
	  b:setData({
			color="0000ff",
			text=texts[i],
			click=fns[i],
	  })
	  buttons[bi] = b
	  bi = bi + 1
	  if i ~= nb then
		 buttons[bi] = nil
		 bi = bi + 1
		 table.insert(cells, spacer)
	  end
   end
   buttons.n = nb * 2 - 1 -- #buttons + #spaces
   elem:setData(cells, buttons)
end

function ListButton.heightOf(n, height, space)
   space = space or 0
   height = height or 30
   return n * height + (n - 1) * space
end
require("util")
UIGroup = Class()

function UIGroup.new(items)
   local self = {items=items}
   setmetatable(self, UIGroup)
   return self
end

function UIGroup:draw()
   for i, v in self.items do
      v:draw()
   end
end

function UIGroup:resize()
   for i, v in self.items do
      v:resize()
   end
end

function UIGroup:destroy()
   for i, v in self.items do
      v:destroy()
   end
   self.items = nil
end

function UIGroup:which(x, y)
   for i, v in self.items do
      local result = v:which(x,y)
      if result then
	 return result
      end
   end
   return nil
end
require("ui/UIElement")
require("data/save")
--[[--
   Takes stylesheet lua files and converts
   them into functions that will calculate
   their size automatically. Useful for when
   you need elements that can respond to
   screen resizing.

   usage:
   `./main ui/style-writer <name>`

   @param argc
   @param argv[2] style to convert
]]
function Start(argc, argv)
   if argc < 2 then
	  print("usage:")
	  print(argv[1] .. " <name>")
	  return nil
   end
   generateStyle("ui/styles/"..argv[2]..".style.lua", dofile("ui/styles/"..argv[2]..".lua"))
   print("done")
end

--[[--
   take a filename and a style and generate the resize function etc and write it to disk at `fname`

   @param fname 
   @param style 
]]
function generateStyle(fname, style)
   local handle = io.open(fname, "w")
   handle:write("return {\n")
   for k,v in pairs(style) do
	  local e = table.tostring(v.e or {})
	  handle:write(k .. " = {e=")
	  handle:write(e)
	  handle:write(",\nresize=function(self)\nlocal d = self.d\n")
	  if v.vars then
		 for i,var in ipairs(v.vars) do
			handle:write("local " .. var .. "\n")
		 end
	  end
	  todo = {"h", "w", "x", "y"}
	  for i,var in ipairs(todo) do
		 local val = v[var] or 0
		 handle:write("self." .. var .. " = " .. v[var] .. "\n")
	  end
	  handle:write("end\n},\n")
   end
   handle:write("}")
   handle:close()
end
require("util")
UIGroup = class()

function Group.new(items)
   local self = {items=items}
   setmetatable(self, UIGroup)
   return self
end

function Group:draw(self)
return {
   screen={
	  h="SCREEN_HEIGHT",
	  w="SCREEN_WIDTH",
	  x=0,
	  y=0
   },
   button={
	  vars={"p=self.p","s=10","col=4","w=(p.w - s * (col + 1))//col",
			"h=(p.h - s * (col + 1))//col"},
	  w="w",
	  h="h",
	  x="(d[1] + 1)*s + d[1]*w",
	  y="(d[2] + 1)*s + d[2]*h"
   }
}
return {
   screen={
	  h="SCREEN_HEIGHT",
	  w="SCREEN_WIDTH",
	  x=0,
	  y=0
   }
}
return {
listButton = {e={},
resize=function(self)
local d = self.d
local p=self.p
local h=d.h
local th=(d.n * h + (d.n - 1) * d.s)
local a=d.align
local y=p.y + d.i*(h + d.s) + ((a==1 and 0) or (p.h - th)//((a==2 and 2) or 1))
self.h = h
self.w = p.w
self.x = p.x
self.y = y
end
},
lbContainer = {e={},
resize=function(self)
local d = self.d
local p=self.p
self.h = p.h
self.w = p.w
self.x = p.x
self.y = p.y
end
},
lbChild = {e={},
resize=function(self)
local d = self.d
local p=self.p
local h=d.h
local th=(d.n * h + (d.n - 1) * d.s)
local a=d.align
local y=p.y + ((a==3 and 0) or th)
self.h = p.h-th
self.w = p.w
self.x = p.x
self.y = y
end
},
}return {
screen = {e={},
resize=function(self)
local d = self.d
self.h = SCREEN_HEIGHT
self.w = SCREEN_WIDTH
self.x = 0
self.y = 0
end
},
button = {e={},
resize=function(self)
local d = self.d
local p=self.p
local s=10
local col=4
local w=(p.w - s * (col + 1))//col
local h=(p.h - s * (col + 1))//col
self.h = h
self.w = w
self.x = (d[1] + 1)*s + d[1]*w
self.y = (d[2] + 1)*s + d[2]*h
end
},
}return {
screen = {
resize=function(self)
local d = self.d
self.h = SCREEN_HEIGHT
self.w = SCREEN_WIDTH
self.x = 0
self.y = 0
end
},
dialogue = {
resize=function(self)
local d = self.d
local p=self.p
local s=10
local w=p.w - s * 2
local h=250
self.h = h
self.w = w
self.x = s
self.y = p.h - h - s
end
},
}return {
   actionsPanel={
      vars={"p=self.p"},
      w="200",
      h="p.h",
      x="p.x",
      y="p.y"
   }
}
return {
   money={
      vars={"p=self.p", "w=200"},
      w="w",
      h="30",
      x="p.x + p.w - w",
      y="p.y",
      e={
	 bg={255,0,0,255},
	 justify=3
      }
   }
}
return {
   listButton={
	  vars={"p=self.p","h=d.h","th=(d.n * h + (d.n - 1) * d.s)","a=d.align","y=p.y + d.i*(h + d.s) + ((a==1 and 0) or (p.h - th)//((a==2 and 2) or 1))"},
	  w="p.w",
	  h="h",
	  x="p.x",
	  y="y"
   },
   lbContainer={
	  vars={"p=self.p"},
	  w="p.w",
	  h="p.h",
	  x="p.x",
	  y="p.y"
   },
   lbChild={
	  vars={"p=self.p","h=d.h","th=(d.n * h + (d.n - 1) * d.s)","a=d.align","y=p.y + ((a==3 and 0) or th)"},
	  w="p.w",
	  h="p.h-th",
	  x="p.x",
	  y="y"
   }
}
return {
   screen={
	  h="SCREEN_HEIGHT",
	  w="SCREEN_WIDTH",
	  x=0,
	  y=0
   },
   dialogue={
	  vars={"p=self.p","s=10","w=p.w - s * 2", "h=250"},
	  w="w",
	  h="h",
	  x="s",
	  y="p.h - h - s"
   }
}
return {
money = {e={["bg"]={255,0,0,255},["justify"]=3},
resize=function(self)
local d = self.d
local p=self.p
local w=200
self.h = 30
self.w = w
self.x = p.x + p.w - w
self.y = p.y
end
},
}return {
actionsPanel = {e={},
resize=function(self)
local d = self.d
local p=self.p
self.h = p.h
self.w = 200
self.x = p.x
self.y = p.y
end
},
}return {
screen = {e={},
resize=function(self)
local d = self.d
self.h = SCREEN_HEIGHT
self.w = SCREEN_WIDTH
self.x = 0
self.y = 0
end
},
}return {
   screen={
	  h="SCREEN_HEIGHT",
	  w="SCREEN_WIDTH",
	  x=0,
	  y=0
   },
   box={
	  e={
		 direction=2
	  },
	  vars={"p=self.p","s=10","w=p.w - s * 2", "h=250"},
	  w="w",
	  h="h",
	  x="s",
	  y="p.h - h - s"
   }
}
return {
box = {e={["direction"]=2},
resize=function(self)
local d = self.d
local p=self.p
local s=10
local w=p.w - s * 2
local h=250
self.h = h
self.w = w
self.x = s
self.y = p.h - h - s
end
},
screen = {e={},
resize=function(self)
local d = self.d
self.h = SCREEN_HEIGHT
self.w = SCREEN_WIDTH
self.x = 0
self.y = 0
end
},
}return {"keys.lua"}KEYS = {
   [KEY_SPACE] = " ",
   [KEY_a] = "a",
   [KEY_b] = "b",
   [KEY_c] = "c",
   [KEY_d] = "d",
   [KEY_e] = "e",
   [KEY_f] = "f",
   [KEY_g] = "g",
   [KEY_h] = "h",
   [KEY_i] = "i",
   [KEY_j] = "j",
   [KEY_k] = "k",
   [KEY_l] = "l",
   [KEY_m] = "m",
   [KEY_n] = "n",
   [KEY_o] = "o",
   [KEY_p] = "p",
   [KEY_q] = "q",
   [KEY_r] = "r",
   [KEY_s] = "s",
   [KEY_t] = "t",
   [KEY_u] = "u",
   [KEY_v] = "v",
   [KEY_w] = "w",
   [KEY_x] = "x",
   [KEY_y] = "y",
   [KEY_z] = "z",
   [KEY_0] = "0",
   [KEY_1] = "1",
   [KEY_2] = "2",
   [KEY_3] = "3",
   [KEY_4] = "4",
   [KEY_5] = "5",
   [KEY_6] = "6",
   [KEY_7] = "7",
   [KEY_8] = "8",
   [KEY_9] = "9",
   [KEY_QUOTE] = "'",
   [KEY_QUOTEDBL] = '"',
   [KEY_SLASH] = "/",
   [KEY_BACKSLASH] = "\\",
   [KEY_COMMA] = ",",
   [KEY_PERIOD] = ".",
   [KEY_EQUALS] = "=",
   [KEY_SEMICOLON] = ";",
   [KEY_COLON] = ":",
   [KEY_QUESTION] = "?",
   [KEY_GREATER] = ">",
   [KEY_LESS] = "<",
   [KEY_RIGHTPAREN] = ")",
   [KEY_LEFTPAREN] = "(",
   [KEY_UNDERSCORE] = "_",
   [KEY_PERCENT] = "%",
   [KEY_MINUS] = "-",
   [KEY_PLUS] = "+",
   [KEY_HASH] = "#",
   [KEY_EXCLAIM] = "!",
   [KEY_AT] = "@",
   [KEY_CARET] = "^",
   [KEY_AMPERSAND] = "&",
   [KEY_ASTERISK] = "*",
   [KEY_LEFTBRACE] = "{",
   [KEY_RIGHTBRACE] = "}",
   [KEY_RIGHTBRACKET] = "]",
   [KEY_LEFTBRACKET] = "[",
   [KEY_TICK] = "`"}

SHIFT_KEYS = {
   [KEY_a] = "A",
   [KEY_b] = "B",
   [KEY_c] = "C",
   [KEY_d] = "D",
   [KEY_e] = "E",
   [KEY_f] = "F",
   [KEY_g] = "G",
   [KEY_h] = "H",
   [KEY_i] = "I",
   [KEY_j] = "J",
   [KEY_k] = "K",
   [KEY_l] = "L",
   [KEY_m] = "M",
   [KEY_n] = "N",
   [KEY_o] = "O",
   [KEY_p] = "P",
   [KEY_q] = "Q",
   [KEY_r] = "R",
   [KEY_s] = "S",
   [KEY_t] = "T",
   [KEY_u] = "U",
   [KEY_v] = "V",
   [KEY_w] = "W",
   [KEY_x] = "X",
   [KEY_y] = "Y",
   [KEY_z] = "Z",
   [KEY_QUOTE] = '"',
   [KEY_SLASH] = "?",
   [KEY_BACKSLASH] = "|",
   [KEY_COMMA] = "<",
   [KEY_PERIOD] = ">",
   [KEY_EQUALS] = "+",
   [KEY_SEMICOLON] = ":",
   [KEY_0] = ")",
   [KEY_1] = "!",
   [KEY_2] = "@",
   [KEY_3] = "#",
   [KEY_4] = "$",
   [KEY_5] = "%",
   [KEY_6] = "^",
   [KEY_7] = "&",
   [KEY_8] = "*",
   [KEY_9] = "(",
   [KEY_MINUS] = "_",
   [KEY_RIGHTBRACKET] = "}",
   [KEY_LEFTBRACKET] = "{",
   [KEY_TICK] = "~"
}
PNG

   IHDR   `   @   4r   bKGD  Y    	pHYs        tIME
n   IDATx@P#+j-H00"+fz"3[2              @             Zu-cs|A @              @          \07    IENDB`PNG

   IHDR         tK   bKGD      	pHYs        tIME7\Bn    IDATxw}zt@	#Dq1%Clb'6c6c@Bm=W$$_e73;~W
R )HA
R3+RosRHAfYfd~FGArVK) )d-
 Zr<hA
ERA
R hAN_`KE1 $PD7+?*#,vL9>gZb{ Kb}*iet>Sd\E<EJ.5Tu $7M1:	DAb
/uHK,mmHxJB(qU9tA^A<xT1 Elu~O,|bnA;9Fk:l~i=]ns4++x+8?$8AroO9ER? 54C
:_9y#O_N!'.y*B<\.E&'9XE`U>?CroDTxr8+ZY4EU>N,sO?
%$,_|Y^"V`@RW__/l&ke;m
$:?~|X|hv\l{QSbX Y0iR ) ~
Jt7<pnKW9j O{{{?}}gN_l'VkBq v+'UBEqXB,86wNV 5
iE#{fV -v[,1\za=BQW>Dk7N:s)///WU./7LRKY#,JXT Gqqqlws(u~9455L&inn?`XR nv~rr^mW8yutvv= x+nceBQzzzxGO<IUUR+4hNccP8vwZHIK}(9z(vB.Y_?t<BK]]82R):;;E$7jkkil6.?Qw5G=rhRWWGooo>BQTT.q6l~e@`+`Yx1wqn{w~BqR|C{(fH)h4^JMM*35x'+ @%wW~Rp8f>*7(|>ue=Dc	V;#qS^{\<Elnnllv+ks']7,'CaB/1;m8Nt]gD":;;YnRJO?~\RW\>.]:>?P.\b-ug>nsXM,`g4< t>s-PRRBII	###|>tR-[ JH$x<,_LA&.d) rTH4SJKf=Hb88 >RjKp8IaFXI&SH	R(5 Y*MMM D"Bhd2bXVl6pv,:a r;,`[v9.zG?dD0,7n]s,`ppFoo/xn.]2&UVVqF4e'%Se"8rBq|4r7q8D"y<O\fDn4T
(CUe$@aCQUa\~rJKCH
;v]s/Zj`"=@I+#FEj`8B\v,@Tc47o8zJ^mi(eNeLx?+6sF_JI$!(vjgRk{!Zz477~?wBp]w^EPzIg}`7> }|3EqeaxxJ:;;cG:h%%%b}3gq
;)kW81H,"..gq()v	>KYv<Vuq|Z4_lMTWmPEaF@p#C^T{@jN3gdEEZQQhZ&$
q	 FUUNqn;o"cI_ia/.yI>*044$~?RJ=!B6'k188H(={+044dQjjX~=\sVf#</HFV	N;@s9/r'Wwaz)?vBsaYz5V)%e( 6 P]m.D#w3tH$R(,[6UUon?Fw EC_I;FXu<-t^}  zbE"Ein+^x&~|rt]'L%H{yQSS($I|>]]]TTTPWW7~O|$cUq1|***PMHR;va)e4M84f#(+\wqK//m6n/F{yX,yTTTy8Xn3G&|e(BGG?y3TJ2O|Bx^^~e^yY0x+N__`4^,i:m}Ec>1c=O!+u%,[@QI'y(UW)uRI@0/e$IRP4eKj3nS.]J"R
,^l8R	!uP(Dss3dn%It]b 'N`x^4M#<LtttXGJ.Vsd6zwP[[KKK>u=nwEH}kcRFgg'hb-Ztq`o|455o~!---"D?-[\^]]~ =;`*wb8]HP@"I$R<v)\1hUU n: ni-6` 84l>'Xj<ZDs2WUU]]]B!xFUb1"cnx^EH$BXfg8,@ 4lk<Rai!D%imme]vv;w}77f+Xn)L.~|+({g\s/|>i&jkklX,#B1jU=5ctuGx$fH3Uqt23,*Z-O ZRYl |vD2EUE0GR)ct@u@0%g:x<i.a82`3_ls=G"Y]U};A mmmlX, 6c{7mmm$PU<hiB?_ &A~VJ+::0GS|xei{r/vuiCKjSO*.4Mm}m.	tOEQVTVVh4J,q7D(**66]q8rhhGr|LbL<26yT MMMtwws!7`2l[khrb<R)-[6m###+=j7o-wFJ%Kp\inu]l-;M%3l+Z}J~X^UY2q	<QcIZZ{$!84-_OsT!88k.h8FH>X,F{{;v-vCc=y3b4f``RrF"
+:uV0
>>,?0=ff-Z69<H]]m#J:> 7o&OOK!kUUU]a*eziihg&UEv h+,axxm;[^0!%Iu&gGGEv;0	P):jKiRkY_bfxMNG#Umm-D"1miX H$5J~'$.K niltov5ko~^/gz{{y 8r?T:(twwK:tiZ|-+}}}Ke	eIq9`\sCttS2awk!5^'}A|,_C
@{o
n=e}}Yi.tNZ^^>/..200@8A-T
G4xWUn,nN*"aZQEci0e" :::R
{jdr^]]obPQQG>l#GwySR^ `9rdtpPQQ}iVvH)y'tH7GX(s_@aZz )=.e8f
jQY;|Gu#%$xK""<[n	'Lspx:]	VkT4e=rhhH
!'"8@B(
e>o\!4q&S\\L8ca}}dWpXQ]K1VQ4z2LhLEBfju]W].6mBJK/$GFFysy2\UMBAUcmr(**b-&)_~gEE_mwvww_-RJWSIi*MK{"&O>,+P!R?dS="aL|H$	"ZqVEe$nk_L&5(xFJ[n[NEP$n=h\ ,^(jtM5M#*X922AJ(jehhIg>4R)(+++<qDs0L/	5He"f.Tpj9KkZZZz!rdQQF455AUU$IR{D"SbcB/c	J)Mt[i1X2*0N aIfg|ph?
"c8\6<EAs6u)Dc	H]J,`TJ [u]
8TsJa2IH$gV|(Kr)2#Jfc*vFbNeQQ@iiUUKG29fP(Auvrrz1?UUUUI)uQ:?,F+TU>p jbQTTfaZ1}iF2I0$p8H&{W{(D /waji	3d@P9N9iah@<o>z)Y,\J}EUQ	dJH&54MUJyrir<0$^yA1X,&|;>ad({VJKK].WHUUW*rI)] (1^)//I)T'&d6]oy_{]I(ZPgyoRihd@WJd_*RvH);sNgJQ]]]I)cx#N*%`XJfticfpt%)w$S$]H|f:(sooF7sK;[w{g;Yu\:]~+=1|d! .8&\dbzy1@tP9n"a7aBi FGMOFt]9@g|3~LZ2c'X41 I/lA!18tw6LWDu`yigD&Gv%(3y
Iud,1g0l7=1SYg*q4,
AXJv3~1CMd)y4J\{2L>z^g3"L>?03lNHji<-n&YrPIbSTRyliTgwjgcsykX&w|}l4j1+txRJbXJ6Pr
@:O	9F5J7]r1d{~aE09a9SOG&c*0n ij*a}Bf3Og~NBK)"s<>!~DfVP:6jcNP2hfFgY<1J6?:9bcQSfx&iL!2yIW&28!VL4VB cU*[@ydcful4)GNJLS;/f`3I$^kss0dU6K&dZ@9z6TN+GCVRMr(kF+ds&ir<T\5kA1yl;,Fayb )r\kNLfd"6>EgRg5C.%VE(l	PkM1?tZrajN'bJg>?N8R''OB*,3T*,!l3,U"u*^2_2bSh
3m<1'o;p&c^{nG5b9kNg`a7)HA
Ru.Tx\Af;g.o[psNr55j~Y  IDATxIV`w,Fk0F~.nAr{0^p5l>bcQalSbpo==.FX?)]8<<SJp6lb.r;2Sza#H}29W:
Z~\S$|nC4\7a,_\u!Tbv0m|[9^BEa2p/j;kUK5t<>fr9*Sw.K/l5l Ta&EEu_h59JC3 A*mLX;2-/[k17uxY~]0z`$pH?,g\s	d%'7=aqt:6W`?2||dP?>b+*1V^?O.}yYN'JR:aes<=po%IiAW`,h\6#/sP)*>@IXYOr/Sn7qw6=n9O&8?\Qy]}}jP1FF],+|#Xr4txp]DSq8@QPS9^ 4 co6LQ7);_=<(dZ?	|VxUpupEPe v,6#\SQm;sY)!n,U(
P2P+{#06>1nV>Y.MSqA;-tot*N?do5p:"zepD_.|75jE-o@-J`yv"iY {}6	*pu\|*)2+&_.
A5>6(+bALzc`nVM36[%V=8t.FXmkqvNY61'1	xr~Oq0w"9p1EX.AouS7J	\_?gI2(f(B#|
xOcezWPX8Yk5GiiND{ jLyC+sXKlJsG~co5C	|85TLO S5cS(6gPUo'KR1`])zN6\ZQM <IbXoh\U 5sX@;tfqz*I|bLNrr?+_|]$u0|nNl2[<\NWAJARQ()R\lX"8KIm0kb`Lge:8"_nn+z[$Dsa8Ne+X
bDh!4za+[x#GzT PbLnf.hDhPEY^Lw@mJice:|1U*Z+h"y079U+\rI	)`8#s`7h[|P2h}[|&932UpX}yu>b4q\ZFw7t,3<K,H5fY3o)B`ycfN;7>&qIq\/:;IS3q'@P-nd*>i8OTss/.*JSo0E.6ng.DqO'#"(:=|.'jTe+n]+<kM 8FF~(Nxa,8~|cWfFxp.}R8eG).gm=e^:G{~YPOai:VQoj-bl4_A$5$:p}7\[<'02BSUnpZRZVpj2xTjg/;[X3B 'V*R9)l}@<@UTP3Zn{%a<7}NH&[;=34$`#]WGO)$6X8'0vwZ<]IvF&R3AmnEDy$zsrAC-"#'2e=t87n~},g9m!Nt	*2/sn
of(D}yz\Cfg^2|,tF&oW;p}+.h* *RZdBIxUcst'@KqQ\ux#Dv)5k,_
~{Bc#w">Q,,]x'*%H=ukik cO0L	W07wMI%6e_cDk{[-YjxXq#,*BY!H;By5$NI%h	 Ec!Z<37uP C(:z7R\}U>:zGjzz"d5aN^x73bF'1^*A!
%Uw^WekX-#6lE#C!X	M` =_B%A<~B`</	/SHE-x[haY70bS(]F>bSz[c^zWYq/qs{O6V0^:fa~5E`i#\\heUWM,YdJz6NcI$<L>}cZi
M,
^Y[K^n:aho@[oy%6ry%pZ0%Sh(-a0
)X1ec@Yr aKR2r~|kp'!+]fc3flWYy0-U=%i)r0fI4E=`H&uq=hOsp-YU:</ur~E2dNj(l1VO:QES6BVB<5p&@8BF2a	}}	hKLneJ<t&k35$@'!B$z\s3C]K3vFqI6fyF\D	t-&'7B\F8|L@^FE;XG7Lbb+DTWp-a@w cLv4H%me+r)'4tJTr4Ar).>hV#=wB$#]dH'nh'=lxlpUu=#i3FcQ]4"!Z:v=Ox }_#IA>\	ZIiksa"<nq=5uew{=tq}0:FoI]>8jl0>0H7DLO$JB|]
xY@a.t16$722'1uSc&f[>|E-)hV)/NKx mgaww*ChL wn')K(W'O=cxeuJQCDy?pxv;|IR()Y	
hTg0)$0>#'l>bI,9{29Cwi!{1S%riq)S:rD}oM7EFpkR>t3_+]k*.)iaw?_h8,:N'fs4{O0t^VT}na@JW4KK,=TVZORmsP8G"-}n[h*gqX	`2|5*2/"b-72=!0ICCq5ctp0{?.'3:+(q*V2FWEJh3@/YR*sKw?/`wv:ah-}\{yB	a&DeH(
]wFqixo&K>f5pOe
qU-kxf

;2;94#Y<=c*\&Us|qBa]S'un"us.k>XK9_fuF7cg+2#`$%	FyL8c$rShd1]t1<@HQ,eZSJJl"{l#%elDE1=hO7:sxF2TKkQK71	dQ`L/cl>RNn7014]o~S5WuYXq B0fL5nYaz^t5B,X<,ht
V-L#*N_>)+2]d]\x5Mt dezphqfc5 Y8z.}hTL`'hz^`B*2g.4-D{RAZ:}u8J,$4Tow>fA?b|
*``2eMOP19a7&<dF8@q:([
$=10+ul;D)w.t_b$g,"oUBCWyh.<U%\73o\B5--_@ &yac<KwOxily&)@c~&AbCY3t[;nY} -o& .
Nnc4Y->M#7Lw
/03eeWR\|	G'fxxCr.{>lK|#6Md=YZj!Azv;=}.f6h2c>3f+~ P:Hrw^_X>~FG&'<=l!] c!|F-,c~l_Pv?>yw!Ylip)1}/LJf/~z`1^oyKpjh6ql?(fv3#<|;MDY/X1v?Iaiv:BSW)Aw2*ip?R*\cJua,Qx#A99LafL0{1dH8yC!`h"m?5=X#,v4E nFIbf	:z?&xsgP&Yo&Emffj!csmk|o#|kdio&;[f9Acas[I#g0fS~lzVefUUdFm%O?!,'f D	,l<[!|6 )HA
R )HA
R 9Dw6=7,VQ?Vd,CD
S!Lvn!<hg#-IHNW<[Rg@L9%Z YAhO$^z\^8j tF,RV_ gL|; -,[B
Rd*E"H:YB!=cF|b{B9@6,@Z%T	'^ {j8HJdbk'^@=-yT6(HAf-8KC
.t<icN
-S	O'a
dQde!,)HA
R )HA
R )HA
R )HA
R )HA
RX    IENDB`PNG

   IHDR   (   (   m   7IDATx1  WG~AAAAAAAAAAAAAAAAAAAAAAAMw    IENDB`PNG

   IHDR         tK   bKGD      	pHYs        tIME +*   IDATx1   Omo                                                                                                             7 9    IENDB`PNG

   IHDR   (   (   m   4IDATx1  7X>AAAAAAAAAAAAAAAAAAAAAAA iak    IENDB`return {"arrs.png","check.png","collectables.png","headsprites.png","sectors/","tailsprites.png","testbody.png","testhead.png","tile.png","tiles.png"}PNG

   IHDR      p   &;   bKGD      	pHYs    (J   tIMEB  IDATxXe?03`\r-V.aiVGX#WJMhVmCnVs3WU1Nh!Q.ffw{]p;s?}?AuFPlHww4Ryx6[Pf~(?W'Vx4Jk\u{x"H,`	0mK|ijy{@	T^I5\glZZl"O(=m] =dw.%4eTOe2baFm48+I]r1)0Ge4X1m|Wo]L-5\I}2$]eLh^XBDs5EAh[oAyF#)I45d4.T*X4xB%gf>2L"Dadu9DYZt5dwKK{jC~qB,'sd/"T|3/*vac`Eb(H+$.;cL&]f6
E2mOesbz%Ck-+yJFlg+aZ%)eFP]WdqL1	^b9s?dP\;vg3Y4~!#mV\H~oU^TTpUt^BlpWoL-KFGZpKy&o_Xc2[ENb-Z'CeKxv1S:Mw2*Fqh2nyg(	wXWtveUP0q2bZ ehujl{S:qzbcYYF;)p	A-DTT/U%^[Abk-u!N0W'k_oZ2zJlXDL#PPd'c'YX82=y_"L32(4=CrJ%xBVS&C`6~ZUf9{(6'3O2~fsx_	_AM&bxQ~}/T91d,ccxP3bc8[s0~RrKr_M}H:Ot%>30dvshC_/t?l 6?)#9EL9o\pf |reTsQ3a4edS8!z(5w'[ew-[|/]<!I 
8FB3{&
AA.cr`iQn^w3uVjD_2zd
"Z2vgATGY3;C;(~Fg,j$iuI&By*ig/666Rw?bcz4%(vyc%KKhNs\R!iNCWa{,;<jollJ*(? ~Jv>Jwh1w2iL4u"8[
iR).;V4}GmPQ=&[O/9O`a<QU'_s{!h[
s^:ek8yDTl*A1n?	?1Lw'5l9eMm$-i77a}1W~SV.;{++m5ATNWD|+lqGM} *6dG`Jt"BWG\FkkpOwrc;t^
ZF|1.E4!Fz_qN"FTiN"D+^db+bQ`i"S*NRy~,qf5dRdu6hb]s\l	K%QVW$3U'JXeVss`6O/dB&GemZS-5\U:+H{p@x]2e[9$Ut:Be.e]](s?dbUl)i;t.5YG)r&%.%vGL#HY&32bW!NQ*#4:kN #3m]{E:O8?oZ7lw%L`w]F.b@	@	
e.ujoP2s,#G$Gjb$HxD(g]3F`v6KX<Ci=kxktac*VB/Y{hKHJUwg,L_}e|-#7"vd[XPr1Eea<~9(#/L&r/,1{2}TJ42zK#cV!9~jZO4%'$tzr^3odiZE3\f\Ij-_ui"!f>)L?G[] -*E#:$j'D[GAe.TCHe9Q!T}A537a(5d2)[*A'ORaMg(ZZ,*LA,~oX3HiPL&E0R\H3@\&w<E	zR-+^Ar>OUF$ov*FA__%LvIkPRa~2QuX#9|*F_-%H{>>0b0[E!D+kLe~f,vSnX.y#e+ktV-ApJ+gwnhi=kdWH3}* $WR\9;/*g4G]y<9_ICpW<$~v	#KVZhId=ziIPhVHnwH[NZ:jYeHVp+,-2:T5z{~1A']l1_/	rGL+t(urHdRunRQco24E_/	:r'T6`L"*9Qqvpf*9NPK$W3H#u_rF&U26u>@rvr5pf"^T!)VbMR~2SXC"Y{=5:,B)r%A}=+{a	=Q9YAf*qhL:"4;#g`K9TFMa+-bl&9Vb"z+Lj0r9-z,_/	tDRd%ytQ<!b-5:
!u%g-Ab%A}H$)adgz#cif@q!Dk)<a-P{rv':LQOg8S*scT> wb0.5PO}se%mmE:OI,$FZ+gwxc[a5&2UDlX95xXr?d	e6hA~ WA)6y\kM@/(FA6ck-[bs[0 o5uqT#^sz6Tv QQ[=u'%SQ~2ep%+xwtt]}S5vv5H deuTf:Il)<!vw6j ,#:Hl;h|2=Euwu8irj4e_u|xu)7O 	Ini)l7Ge+9U3=g']!n;>
5@w.7(?3Mq7A{u^3c#g<)]w(L)_Ngv~VrFgAQ;A]4a)-7r8rZ+9\J0QLVyMz69"^BZsO+LnhF='
!;(}X=$ 5vA
Pfnrp|=?R`npuB2SYp=Cg|m-M2'S0._	?3X"8XA%3W2]>7V"NNF^!z3w%JNmwHAZ/o6mGLmWyd0k4jzb-]xgOu%>O;n%Ikm63UZX4zLtN^8(att8uv#:'@07P0O!LV& H`5pF#a2t9ouv I`cFg:~g&#M4WOz_oc#-AEzviX!RGd6~\B0_@XT-(4hh5:PJ	`uA'N8qH/N mfs1$
\G?gyo}!{l6iSOA9ISOAcF;ti' 	
d>Et:vb0@WXWgm[o`mYJ&=JS# bu(}UftKN/t$(wpHTARr)(Ag    IENDB`PNG

   IHDR            bKGD      	pHYs        tIMEU/v4  IDAT8;K$A3 b` 	c  #Gn :85@]@YZ:vOMw;{RQG$E.(;. <x~. _t] \|&Rt`;;&f"MTu.j 	]uDU;==wG[rxiI%P2a"d_y| [Z\YaasCF;;I"ONZ "kk==%{{cy~6UP&Ij`|)#{rt477Y~ EuXccX$>1su~DioZHUS_B63Cau9l$&. [qTjr95'1& J  UPRcL>?/u*]    IENDB`PNG

   IHDR   (   (   m  kIDATxgHUqLK-3-QeR,(C0ZeQ4,;lQ  (v1Uw9>@ x/rKOs2oPPm/gN` yLC5J.8~ U05/ v;[76 CK+'
`bGaVr`O/ <_Q +:go{Yr%bEj0x=oi6M1=VyoWmy	eRS+
E76g^|k'tNX3r2 0*<(b8A`OGZ[}E/pSGyv0
B!2=Ew2k`pu7su]J2WZZJ$2Irr sU\
AK5<h_j*\vz*6(a
R^RmL],<(zI4p '1m
`L.XAV0zx87{q 7-4|./+TjKu[s6U^ n)X.bCS6iPphX +~I&;:,
xhANpFnV #Q}J{ a2gsW6)70y)6ftB6xu;xf%4{%`?W#"nun,s`
J=ljp{w]>?,2w^E}|>@K[    IENDB`PNG

   IHDR   @   @   iq   bKGD      	pHYs        tIME9<   tEXtComment Created with GIMPW  <IDATxYo45PT\Dd]5HLDLQgn Lk2:3cpz:eREt)c{>8[T5)RJ)UR~{>;;/~:~OJ9s+'IWSTu`[Bu`|`ehhpqsbCp#8R*+8d p/8VR9PC<y ?5+hc_&
4@'Y@kez/sp=k0CZp<,7YoUa<3p'p=w9<_%VVZ3tS?]{ov`xU_8Mfk5fXFx=k)X4 v?`:8;EYy}p@H)RJ)RJ)RJ)RJ)T]P    IENDB`PNG

   IHDR   d   d   pT   bKGD      	pHYs        tIME	D   tEXtComment Created with GIMPW  IDATxAr0DQ8{U)3#kWd=8dY     @Es\JBte*FWvB4r18SbhYB<wG%l7dQM-S$C; ((
}M(W.`UN|?o!Il]6wB[FV;zwAJ$E*.c/H'l9^-e9w?xTG%z'FVT1CDx+    @zBb1y:|zd=pw]e #uNMNmqj-A tIgk2;>2pei\.!UkG_4j\(1!Hqej\.1#     4    IENDB`/*
  SDL_image:  An example image loading library for use with SDL
  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/
The source code to this library used with SDL_image can be found here:
http://www.libsdl.org/projects/SDL_image/libs/
---

Copyright notice:

 (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

If you use the zlib library in a product, we would appreciate *not* receiving
lengthy legal documents to sign.  The sources are provided for free but without
warranty of any kind.  The library has been entirely written by Jean-loup
Gailly and Mark Adler; it does not include third-party code.

If you redistribute modified sources, we would appreciate that you include in
the file ChangeLog history information documenting your changes.  Please read
the FAQ for more information on the distribution of modified source versions.
return {"ABOUT.txt","LICENSE.SDL2.txt","LICENSE.SDL2_image.txt","LICENSE.SDL2_mixer.txt","LICENSE.SDL2_ttf.txt","LICENSE.freetype.txt","LICENSE.jpeg.txt","LICENSE.mozart.txt","LICENSE.ogg-vorbis.txt","LICENSE.png.txt","LICENSE.tiff.txt","LICENSE.zlib.txt"}Simple DirectMedia Layer
Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
  
This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
  
1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
/*
  SDL_ttf:  A companion library to SDL for working with TrueType (tm) fonts
  Copyright (C) 1997-2016 Sam Lantinga <slouken@libsdl.org>

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/
The source code to this library used with SDL_image can be found here:
http://www.libsdl.org/projects/SDL_image/libs/
---

Copyright (c) 1988-1997 Sam Leffler
Copyright (c) 1991-1997 Silicon Graphics, Inc.

Permission to use, copy, modify, distribute, and sell this software and 
its documentation for any purpose is hereby granted without fee, provided
that (i) the above copyright notices and this permission notice appear in
all copies of the software and related documentation, and (ii) the names of
Sam Leffler and Silicon Graphics may not be used in any advertising or
publicity relating to the software without the specific, prior written
permission of Sam Leffler and Silicon Graphics.

THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  

IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
OF THIS SOFTWARE.
/*
  SDL_mixer:  An audio mixer library based on the SDL library
  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/
The source code to this library used with SDL_image can be found here:
http://www.libsdl.org/projects/SDL_image/libs/
---

LEGAL ISSUES
============

In plain English:

1. We don't promise that this software works.  (But if you find any bugs,
   please let us know!)
2. You can use this software for whatever you want.  You don't have to pay us.
3. You may not pretend that you wrote this software.  If you use it in a
   program, you must acknowledge somewhere in your documentation that
   you've used the IJG code.

In legalese:

The authors make NO WARRANTY or representation, either express or implied,
with respect to this software, its quality, accuracy, merchantability, or
fitness for a particular purpose.  This software is provided "AS IS", and you,
its user, assume the entire risk as to its quality and accuracy.

This software is copyright (C) 1991-2016, Thomas G. Lane, Guido Vollbeding.
All Rights Reserved except as specified below.

Permission is hereby granted to use, copy, modify, and distribute this
software (or portions thereof) for any purpose, without fee, subject to these
conditions:
(1) If any part of the source code for this software is distributed, then this
README file must be included, with this copyright and no-warranty notice
unaltered; and any additions, deletions, or changes to the original files
must be clearly indicated in accompanying documentation.
(2) If only executable code is distributed, then the accompanying
documentation must state that "this software is based in part on the work of
the Independent JPEG Group".
(3) Permission for use of this software is granted only if the user accepts
full responsibility for any undesirable consequences; the authors accept
NO LIABILITY for damages of any kind.

These conditions apply to any software derived from or based on the IJG code,
not just to the unmodified library.  If you use our work, you ought to
acknowledge us.

Permission is NOT granted for the use of any IJG author's name or company name
in advertising or publicity relating to this software or products derived from
it.  This software may be referred to only as "the Independent JPEG Group's
software".

We specifically permit and encourage the use of this software as the basis of
commercial products, provided that all warranty or liability claims are
assumed by the product vendor.


The Unix configuration script "configure" was produced with GNU Autoconf.
It is copyright by the Free Software Foundation but is freely distributable.
The same holds for its supporting scripts (config.guess, config.sub,
ltmain.sh).  Another support script, install-sh, is copyright by X Consortium
but is also freely distributable.

The IJG distribution formerly included code to read and write GIF files.
To avoid entanglement with the Unisys LZW patent (now expired), GIF reading
support has been removed altogether, and the GIF writer has been simplified
to produce "uncompressed GIFs".  This technique does not use the LZW
algorithm; the resulting GIF files are larger than usual, but are readable
by all standard GIF decoders.

Operator 12 was developed by:
Steph Oro
Eric Londres

Operator 12's source is at present under the MIT license

View online at https://github.com/gaycodegal/operator-12

:D
MOZART NBP
made by Nate Halley
using FontStruct
Version 1.0
Date: 02 January 2014

DESCRIPTION
===========
An 8-bit BASIC interpreter-styled typeface.

LICENSE
=======
Mozart is Creative Commons (by-sa) Attribution Share Alike. That means it's free to download and use. You can also upload it to another website but only as long as you give me credit for making it. You can even make changes to it as long as you give me credit for making the first version and license your new version as CC-BY-SA too.
For more information, go to:
http://creativecommons.org/licenses/by-sa/3.0/

A REQUEST FROM NATE547
======================
Once you install this font, find 2 ways to make the world, the country, your home state/province/county, or your hometown better than it is. Even if it's just recycling your newspaper instead of tossing it on the rubbish.
Of course, you're not obligated by law to do this.... it's just a request from a Sensible Human who wants our world to change.

Duty now for the future.

Nate547 (total FontGeek)
The source code to this library used with SDL_mixer can be found here:
http://www.libsdl.org/projects/SDL_mixer/libs/
---

Copyright (c) 2002-2008 Xiph.org Foundation

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

- Neither the name of the Xiph.org Foundation nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
The source code to this library used with SDL_image can be found here:
http://www.libsdl.org/projects/SDL_image/libs/
---

This copy of the libpng notices is provided for your convenience.  In case of
any discrepancy between this copy and the notices in the file png.h that is
included in the libpng distribution, the latter shall prevail.

COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:

If you modify libpng you may insert additional notices immediately following
this sentence.

This code is released under the libpng license.

libpng versions 1.0.7, July 1, 2000 through 1.6.32, August 24, 2017 are
Copyright (c) 2000-2002, 2004, 2006-2017 Glenn Randers-Pehrson, are
derived from libpng-1.0.6, and are distributed according to the same
disclaimer and license as libpng-1.0.6 with the following individuals
added to the list of Contributing Authors:

   Simon-Pierre Cadieux
   Eric S. Raymond
   Mans Rullgard
   Cosmin Truta
   Gilles Vollant
   James Yu
   Mandar Sahastrabuddhe
   Google Inc.
   Vadim Barkov

and with the following additions to the disclaimer:

   There is no warranty against interference with your enjoyment of the
   library or against infringement.  There is no warranty that our
   efforts or the library will fulfill any of your particular purposes
   or needs.  This library is provided with all faults, and the entire
   risk of satisfactory quality, performance, accuracy, and effort is with
   the user.

Some files in the "contrib" directory and some configure-generated
files that are distributed with libpng have other copyright owners and
are released under other open source licenses.

libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
libpng-0.96, and are distributed according to the same disclaimer and
license as libpng-0.96, with the following individuals added to the list
of Contributing Authors:

   Tom Lane
   Glenn Randers-Pehrson
   Willem van Schaik

libpng versions 0.89, June 1996, through 0.96, May 1997, are
Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
and are distributed according to the same disclaimer and license as
libpng-0.88, with the following individuals added to the list of
Contributing Authors:

   John Bowler
   Kevin Bracey
   Sam Bushell
   Magnus Holmgren
   Greg Roelofs
   Tom Tanner

Some files in the "scripts" directory have other copyright owners
but are released under this license.

libpng versions 0.5, May 1995, through 0.88, January 1996, are
Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.

For the purposes of this copyright and license, "Contributing Authors"
is defined as the following set of individuals:

   Andreas Dilger
   Dave Martindale
   Guy Eric Schalnat
   Paul Schmidt
   Tim Wegner

The PNG Reference Library is supplied "AS IS".  The Contributing Authors
and Group 42, Inc. disclaim all warranties, expressed or implied,
including, without limitation, the warranties of merchantability and of
fitness for any purpose.  The Contributing Authors and Group 42, Inc.
assume no liability for direct, indirect, incidental, special, exemplary,
or consequential damages, which may result from the use of the PNG
Reference Library, even if advised of the possibility of such damage.

Permission is hereby granted to use, copy, modify, and distribute this
source code, or portions hereof, for any purpose, without fee, subject
to the following restrictions:

  1. The origin of this source code must not be misrepresented.

  2. Altered versions must be plainly marked as such and must not
     be misrepresented as being the original source.

  3. This Copyright notice may not be removed or altered from any
     source or altered source distribution.

The Contributing Authors and Group 42, Inc. specifically permit, without
fee, and encourage the use of this source code as a component to
supporting the PNG file format in commercial products.  If you use this
source code in a product, acknowledgment is not required but would be
appreciated.

END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.

TRADEMARK:

The name "libpng" has not been registered by the Copyright owner
as a trademark in any jurisdiction.  However, because libpng has
been distributed and maintained world-wide, continually since 1995,
the Copyright owner claims "common-law trademark protection" in any
jurisdiction where common-law trademark is recognized.

OSI CERTIFICATION:

Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
a certification mark of the Open Source Initiative. OSI has not addressed
the additional disclaimers inserted at version 1.0.7.

EXPORT CONTROL:

The Copyright owner believes that the Export Control Classification
Number (ECCN) for libpng is EAR99, which means not subject to export
controls or International Traffic in Arms Regulations (ITAR) because
it is open source, publicly available software, that does not contain
any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
734.7(b).

Glenn Randers-Pehrson
glennrp at users.sourceforge.net
April 1, 2017
The source code to this library used with SDL_ttf can be found here:
http://www.libsdl.org/projects/SDL_ttf/libs/
---

                    The FreeType Project LICENSE
                    ----------------------------

                            2006-Jan-27

                    Copyright 1996-2002, 2006 by
          David Turner, Robert Wilhelm, and Werner Lemberg



Introduction
============

  The FreeType  Project is distributed in  several archive packages;
  some of them may contain, in addition to the FreeType font engine,
  various tools and  contributions which rely on, or  relate to, the
  FreeType Project.

  This  license applies  to all  files found  in such  packages, and
  which do not  fall under their own explicit  license.  The license
  affects  thus  the  FreeType   font  engine,  the  test  programs,
  documentation and makefiles, at the very least.

  This  license   was  inspired  by  the  BSD,   Artistic,  and  IJG
  (Independent JPEG  Group) licenses, which  all encourage inclusion
  and  use of  free  software in  commercial  and freeware  products
  alike.  As a consequence, its main points are that:

    o We don't promise that this software works. However, we will be
      interested in any kind of bug reports. (`as is' distribution)

    o You can  use this software for whatever you  want, in parts or
      full form, without having to pay us. (`royalty-free' usage)

    o You may not pretend that  you wrote this software.  If you use
      it, or  only parts of it,  in a program,  you must acknowledge
      somewhere  in  your  documentation  that  you  have  used  the
      FreeType code. (`credits')

  We  specifically  permit  and  encourage  the  inclusion  of  this
  software, with  or without modifications,  in commercial products.
  We  disclaim  all warranties  covering  The  FreeType Project  and
  assume no liability related to The FreeType Project.


  Finally,  many  people  asked  us  for  a  preferred  form  for  a
  credit/disclaimer to use in compliance with this license.  We thus
  encourage you to use the following text:

   """
    Portions of this software are copyright  <year> The FreeType
    Project (www.freetype.org).  All rights reserved.
   """

  Please replace <year> with the value from the FreeType version you
  actually use.


Legal Terms
===========

0. Definitions
--------------

  Throughout this license,  the terms `package', `FreeType Project',
  and  `FreeType  archive' refer  to  the  set  of files  originally
  distributed  by the  authors  (David Turner,  Robert Wilhelm,  and
  Werner Lemberg) as the `FreeType Project', be they named as alpha,
  beta or final release.

  `You' refers to  the licensee, or person using  the project, where
  `using' is a generic term including compiling the project's source
  code as  well as linking it  to form a  `program' or `executable'.
  This  program is  referred to  as  `a program  using the  FreeType
  engine'.

  This  license applies  to all  files distributed  in  the original
  FreeType  Project,   including  all  source   code,  binaries  and
  documentation,  unless  otherwise  stated   in  the  file  in  its
  original, unmodified form as  distributed in the original archive.
  If you are  unsure whether or not a particular  file is covered by
  this license, you must contact us to verify this.

  The FreeType  Project is copyright (C) 1996-2000  by David Turner,
  Robert Wilhelm, and Werner Lemberg.  All rights reserved except as
  specified below.

1. No Warranty
--------------

  THE FREETYPE PROJECT  IS PROVIDED `AS IS' WITHOUT  WARRANTY OF ANY
  KIND, EITHER  EXPRESS OR IMPLIED,  INCLUDING, BUT NOT  LIMITED TO,
  WARRANTIES  OF  MERCHANTABILITY   AND  FITNESS  FOR  A  PARTICULAR
  PURPOSE.  IN NO EVENT WILL ANY OF THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE  FOR ANY DAMAGES CAUSED  BY THE USE OR  THE INABILITY TO
  USE, OF THE FREETYPE PROJECT.

2. Redistribution
-----------------

  This  license  grants  a  worldwide, royalty-free,  perpetual  and
  irrevocable right  and license to use,  execute, perform, compile,
  display,  copy,   create  derivative  works   of,  distribute  and
  sublicense the  FreeType Project (in  both source and  object code
  forms)  and  derivative works  thereof  for  any  purpose; and  to
  authorize others  to exercise  some or all  of the  rights granted
  herein, subject to the following conditions:

    o Redistribution of  source code  must retain this  license file
      (`FTL.TXT') unaltered; any  additions, deletions or changes to
      the original  files must be clearly  indicated in accompanying
      documentation.   The  copyright   notices  of  the  unaltered,
      original  files must  be  preserved in  all  copies of  source
      files.

    o Redistribution in binary form must provide a  disclaimer  that
      states  that  the software is based in part of the work of the
      FreeType Team,  in  the  distribution  documentation.  We also
      encourage you to put an URL to the FreeType web page  in  your
      documentation, though this isn't mandatory.

  These conditions  apply to any  software derived from or  based on
  the FreeType Project,  not just the unmodified files.   If you use
  our work, you  must acknowledge us.  However, no  fee need be paid
  to us.

3. Advertising
--------------

  Neither the  FreeType authors and  contributors nor you  shall use
  the name of the  other for commercial, advertising, or promotional
  purposes without specific prior written permission.

  We suggest,  but do not require, that  you use one or  more of the
  following phrases to refer  to this software in your documentation
  or advertising  materials: `FreeType Project',  `FreeType Engine',
  `FreeType library', or `FreeType Distribution'.

  As  you have  not signed  this license,  you are  not  required to
  accept  it.   However,  as  the FreeType  Project  is  copyrighted
  material, only  this license, or  another one contracted  with the
  authors, grants you  the right to use, distribute,  and modify it.
  Therefore,  by  using,  distributing,  or modifying  the  FreeType
  Project, you indicate that you understand and accept all the terms
  of this license.

4. Contacts
-----------

  There are two mailing lists related to FreeType:

    o freetype@nongnu.org

      Discusses general use and applications of FreeType, as well as
      future and  wanted additions to the  library and distribution.
      If  you are looking  for support,  start in  this list  if you
      haven't found anything to help you in the documentation.

    o freetype-devel@nongnu.org

      Discusses bugs,  as well  as engine internals,  design issues,
      specific licenses, porting, etc.

  Our home page can be found at

    http://www.freetype.org


--- end of FTL.TXT ---
require("slug/Skills")
require("battle/ui")
Player = {}

--[[--
   Prepares current slug to be controlled
]]
function Player.prepareCurrentSlug()
   local slug = Player.slugs[Player.turni]
   local head = slug.head
   Player.slug = slug
   Player.gameOver = false
   Player.pos = head.pos
   Player.moves = slug.stats.moves
   active = Player.move
   Player.slug:movementOverlay(Player.moves)
   BattleUI.setSlug(slug)
end

--[[--
   Sets the slug into attack mode
]]
function Player.beginAttack()
   Player.slug:destroyOverlay()
   Player.slug:basicOverlay(Player.slug.action.range, Slug.attackOverlayFn)
   active = Player.attack   
end

--[[--
   Trigger player losing the battle
]]
function Player.lose()
   Player.gameOver = true
   End()
   Util.setController(MapSelect)
   Start()
end

--[[--
   Trigger player battle win
]]
function Player.win()
   Player.gameOver = true
   End()
   Util.setController(MapSelect)
   Start()
end

--[[--
   wipe variables
]]
function Player.returnControl()
   if Player.slug then
      Player.slug:destroyOverlay()
   end
   Player.slug = nil
   Player.pos = nil
   Player.moves = nil
   Player.slugs = nil
   Player.turni = nil
   Player.nslugs = nil
   active = nil
end

--[[--
   prepare for player turn
]]
function Player.prepareForTurn()
   Player.slugs = {} -- active slugs
   Player.turni = 1 -- which slug's turn is it
   j = 1
   for i, slug in pairs(slugs) do
      if slug then
	 if slug.team == 1 then
	    Player.slugs[j] = slug
	    j = j + 1
	 end
      end
   end
   Player.nslugs = j-1 -- number of enemies to go.
   if Player.nslugs <= 0 then
      Player.returnControl()
      Player.lose()
      return
   end
   Player.prepareCurrentSlug()   
end

--[[--
   Player move a slug by one tile

   @param x 
   @param y 
]]
function Player.move(x, y)
   if Player.moves > 0 then
      if Player.slug:move(x,y) then
	 Player.moves = Player.moves - 1
      end
   end
   Player.slug:destroyOverlay()
   if Player.gameOver then
      return
   end
   Player.slug:movementOverlay(Player.moves)
   if Player.moves <= 0 then
      Player.beginAttack()
   end
end

--[[--
   Player attempt attack

   if the player chooses an invalid square it will 

   @param x 
   @param y 
]]
function Player.attack(x,y)
   local ind = map:indexOf(x,y)
   local obj = map.objects[ind]
   local skill = Skills[Player.slug.action.skill]
   if skill.can(Player.slug, obj, ind, x, y)  then
      skill.act(Player.slug, obj, ind, x, y)
   end
   Player.nextTurn()
end

--[[--
   moves onto the next slug or team
]]
function Player.nextTurn()
   Player.turni = Player.turni + 1
   if Player.turni > Player.nslugs then
      Player.returnControl()
      AI.prepareForEnemyTurns()
   else
      Player.prepareCurrentSlug()
   end
end
return {"ai.lua","player.lua"}require("util")
AI = Class()
--[[--
   creates a new AI

   @param algo Supposed to be algorithm to calculate distance/path or whatnot but like there's only one way we do that so kinda moot. Also should be reworked if we intend to have multiple algos

   @return an AI
]]
function AI.new (algo)
   self = {algo=algo}
   setmetatable(self, AI)
   return self
end

--[[--
   find all segments not on <nteam>

   @param nteam the team's number. Usually player's team is 1
]]
function AI.findAll(nteam)
   local all = {}
   j = 1
   for i, o in ipairs(map.objects) do
	  if o and o.slug and o.slug.team ~= nteam then
		 all[j] = o
		 j = j + 1
	  end
   end
   return all
end

--[[--
   find all spawners
]]
function AI.findSpawners()
   local all = {}
   j = 1
   for i, o in ipairs(map.objects) do
	  if o and o.slug and o.slug.spawner then
		 all[j] = o
		 j = j + 1
	  end
   end
   return all
end

--[[--
   Prepare for each new AI controlled slug's turn
]]
function AI.prepareCurrentSlug()
   local slug = AI.slugs[AI.turni]
   local head = slug.head
   local all = AI.findAll(slug.team)
   if #all <= 0 then
	  AI.returnControl()
	  Player.lose()
	  return
   end
   AI.slug = slug
   AI.pos = head.pos
   AI.target = AI.sortDist(all, head.pos)[1]
   AI.tpos = AI.target.pos
   AI.moves = slug.stats.moves
   AI.slug:movementOverlay(AI.moves)
   AI.state = AI.delay
   AI.path = AI.pathTo(AI.tpos[1], AI.tpos[2])
   AI.pathi = #AI.path - 1
end

--[[
   Delay???
]]
function AI.delay()
   AI.state = AI.move
end

--[[--
   Return control to the usurped class, trigger's player turn
]]
function AI.returnControl()
   if AI.slug then
	  AI.slug:destroyOverlay()
   end
   AI.slug = nil
   AI.pos = nil
   AI.target = nil
   AI.tpos = nil
   AI.moves = nil
   AI.state = nil
   AI.slugs = nil
   AI.turni = nil
   AI.neslugs = nil
   Update = AI.oldUpdate
   AI.oldUpdate = nil
   active = AI.oldActive
   AI.oldActive = nil
   framedelay = AI.oldDelay
   static.framedelay(framedelay)
   AI.oldDelay = nil
   Player.prepareForTurn()
end

--[[
   score options by distance to target (H score)
   if distance equal, choose shorter path

   for heap

   @param x
   @param y
]]
local function scoreDist(x,y)
   if x[4] == y[4] then
	  return x[3] < y[3]
   end
   return x[4] < y[4]
end

--[[
   score options by f-score

   for heap

   @param x
   @param y
]]
local function scoreF(x,y)
   return x[5] < y[5]
end

--[[--
   Calculates path between current enemy slug and position
   
   A* pathing.
   H: Heuristic
   G: Path cost
   F: H + G
   
   Node: {X, Y, G, H, F, PARENT}

   @param x 
   @param y 

   @return the path
]]
function AI.pathTo(x,y)
   local heap = require 'algorithms/heap'
   local H = AI.manhatten
   local closed = Heap.new(scoreDist) -- scoreDist determines whether heap is min or max
   local open = Heap.new(scoreF)
   local visited = {}
   local tmp,cur,ind,owner,old,g
   local hpos = AI.slug.head.pos
   local goal = {x,y}
   local deltas = {{0,-1},{1,0},{0,1},{-1,0}}

   tmp = H(hpos, goal)
   open:push({hpos[1],hpos[2],0,tmp, tmp})
   --print("start", hpos[1], hpos[2])
   --print("goal", goal[1], goal[2])
   repeat
	  cur = open:pop()
	  closed:push(cur)
	  ind = map:indexOf(cur[1], cur[2])
	  visited[ind] = {closed, cur}
	  --print("seeing", cur[1], cur[2], ":", cur[3])
	  if cur[1] == goal[1] and cur[2] == goal[2] then
		 --print("found!")
		 break -- found
	  end
	  
	  for i, d in ipairs(deltas) do
		 g = cur[3] + 1
		 tmp = {cur[1] + d[1], cur[2] + d[2], g}
		 if map:valid(tmp[1], tmp[2]) then
			ind = map:indexOf(tmp[1], tmp[2])
			if visited[ind] then
			   owner = visited[ind][1]
			   old = visited[ind][2]
			else
			   owner = nil
			   old = nil
			end
			if map.map[ind] and (not map.objects[ind] or map.objects[ind].slug == AI.slug) and owner ~= closed then
			   if owner ~= open then
				  tmp[4] = H(tmp, goal)
				  tmp[5] = tmp[4] + tmp[3]
				  tmp[6] = cur
				  open:push(tmp)
				  visited[ind] = {open, tmp}
			   elseif g < old[3] then -- lower cost to reach
				  old[3] = g --update cost
				  old[5] = old[4] + g -- update F score
				  old[6] = cur -- update parent
				  open:rescore(old._ind)
			   end
			end
		 end
	  end
	  cur = nil
   until open.size == 0
   if cur == nil then
	  --path not found
	  cur = closed:pop()
	  --print("closest", cur[1], cur[2])
   end
   local tmp = {}
   i = 1
   while cur do
	  --print(cur[1], cur[2], cur[3])
	  tmp[i] = {cur[1], cur[2]}
	  cur = cur[6]
	  i = i + 1
   end
   --print(table.concat(table.map(tmp, function(k,v) return table.concat(v,",") end), "::"))
   return tmp
end

--[[--
   Prepare for the enemy's turn, where it will control all slugs in it's team.
   Usurps Update function
]]
function AI.prepareForEnemyTurns()
   --Update=static.quit
   AI.slugs = {} -- active enemy slugs
   AI.turni = 1 -- which slug's turn is it
   j = 1
   for i, slug in pairs(slugs) do
	  if slug then
		 if slug.team ~= 1 then
			AI.slugs[j] = slug
			j = j + 1
		 end
	  end
   end
   AI.neslugs = j -- number of enemies to go.
   AI.oldDelay = framedelay
   AI.oldUpdate = Update
   Update = AI.Update
   AI.oldActive = active
   active = nil
   if AI.neslugs <= 1 then
	  AI.returnControl()
	  Player.win()
	  return
   end
   AI.prepareCurrentSlug()
   framedelay = 1000 // 3
   static.framedelay(framedelay)
end

--[[--
   Moves the current slug a single tile, consumes one movement
   sets the AI state to attack when no moves are left
]]
function AI.move()
   if AI.moves > 0 then
	  --[=[local dx = math.min(math.max(AI.tpos[1]-AI.pos[1], -1), 1)
		 local dy = math.min(math.max(AI.tpos[2]-AI.pos[2], -1), 1)
		 local indx = map:indexOf(AI.pos[1] + dx,AI.pos[2])
		 local indy = map:indexOf(AI.pos[1],AI.pos[2] + dy)
		 if dx ~= 0 and dx + AI.pos[1] > 0 and dx + AI.pos[1] < map.width and map.map[indx] and ((not map.objects[indx]) or map.objects[indx].slug == AI.slug) then
		 AI.slug:move(AI.pos[1] + dx,AI.pos[2])
		 AI.moves = AI.moves - 1
		 elseif dy ~= 0 and dy + AI.pos[2] > 0 and dy + AI.pos[2] < map.height and map.map[indy] and ((not map.objects[indy]) or map.objects[indy].slug == AI.slug) then
		 AI.slug:move(AI.pos[1],AI.pos[2] + dy)
		 AI.moves = AI.moves - 1
		 else
		 AI.moves = 0
		 end]=]
	  if AI.path[AI.pathi] then
		 AI.slug:move(AI.path[AI.pathi][1],AI.path[AI.pathi][2])
		 AI.pathi = AI.pathi - 1
		 AI.moves = AI.moves - 1
	  else
		 AI.moves = 0
	  end
   end
   AI.slug:destroyOverlay()
   AI.slug:movementOverlay(AI.moves)
   if AI.moves <= 0 then
	  AI.slug:destroyOverlay()
	  AI.slug:basicOverlay(AI.slug.action.range, Slug.attackOverlayFn)
	  AI.state = AI.attack
   end
end

--[[--
   Does the enemy slug's attack, continues onto next slug or returns control to player if no slugs left to move
]]
function AI.attack()
   local x, y = AI.tpos[1], AI.tpos[2]
   local ind = map:indexOf(x,y)
   local obj = map.objects[ind]
   local skill = Skills[AI.slug.action.skill]
   if skill.can(AI.slug, obj, ind, x, y)  then
	  skill.act(AI.slug, obj, ind, x, y)
   end
   AI.turni = AI.turni + 1
   if AI.turni >= AI.neslugs then
	  AI.returnControl()
   else
	  AI.prepareCurrentSlug()
   end
end

--[[--
   Continue the enemy slug's turn

   This update function does the enemy's turn part by part until there are no more parts and turns to take.

   A turn for an individual slug consists of targeting, moving, and attacking if posible.

   Once there are no more turns to process, control will revert to the usurped Update function
]]
function AI.Update()
   --Update = static.quit
   AI.state()
   if map then
	  map:update()
	  map:draw()
	  if AI.slug then
		 AI.slug:drawOverlay()
	  end
   end
end

--[[--
   Manhatten/taxicab distance between points a and b

   @param a 
   @param b 

   @return distance score
]]
function AI.manhatten(a, b)
   return math.abs(a[1] - b[1]) + math.abs(a[2] - b[2])
end

--[[--
   comparator for manhatten function.

   segments have a ._pos field temporarily, which provides the reference position they are to be compared with

   @param a Slug segment
   @param b Slug segment

   @return whether distance from A to reference pos is less than B
]]
function AI.mancomp (a, b)
   local c = AI.manhatten(a.pos, a._pos) < AI.manhatten(b.pos, a._pos)
   return c
end

--[[--
   Sort list of possible targets by distance

   @param all list of segments that might be possible targets
   @param pos reference position

   @return sorted list (same list)
]]
function AI.sortDist(all, pos)
   Segment._pos = pos
   Segment.__lt = AI.mancomp
   table.sort(all)
   Segment.__lt = nil
   Segment._pos = nil
   return all   
end
require "util"
local isMain = Util.isMain()
Heap = Class()
local H = Heap

--[[--
   make a new Heap
   
   @param cmp(x,y) comparator fn. if cmp(x,y) => x > y 
   then (begin (push x) (push y) (pop)) => x 
   

   @return new boi
]]
function Heap.new(cmp)
   local self = {}
   self.size = 0
   self.data = {}
   self.cmp = cmp or Heap.cmp
   setmetatable(self, H)
   return self
end

--[[--
   Get parent index

   @param i current index

   @return parent index
]]
function Heap.parent(i)
   return (i-2) // 2 + 1
end

--[[--
   Get left child index

   Right = left + 1
   
   @param i Current index

   @return left child index
]]
function Heap.child(i)
   return (i-1) * 2 + 2
end

--[[--
moves an element toward the top of the heap as appropriate

@param i index to move

@return index the element ended up at
]]
function Heap:siftUp(i)
   local p = self.parent(i)
   local d,cmp = self.data,self.cmp
   local t
   while p >= 1 and not cmp(d[p], d[i]) do
	  t = d[p]
	  d[p] = d[i]
	  d[i] = t
	  d[p]._ind = p
	  d[i]._ind = i
	  i = p
	  p = self.parent(i)
   end
   return i
end

--[[--
moves an element toward the bottom of the heap as appropriate

@param p index to move

@return index the element ended up at
]]
function Heap:siftDown(p)
   local l = self.child(p)
   local r = l + 1
   local d,cmp = self.data,self.cmp
   local t
   local cl, cr
   while l <= self.size do
	  cl, cr = not cmp(d[p], d[l]), r <= self.size and not cmp(d[p], d[r])
	  if (cl and not cr) or (cl and cr and cmp(d[l], d[r])) then
		 t = d[p]
		 d[p] = d[l]
		 d[l] = t
		 d[p]._ind = p
		 d[l]._ind = l
		 p = l
	  elseif cr then
		 t = d[p]
		 d[p] = d[r]
		 d[r] = t
		 d[p]._ind = p
		 d[r]._ind = r
		 p = r
	  else
		 break
	  end
	  l = self.child(p)
	  r = l + 1
   end
   return p
end

--[[--
add a thing to the heap. must be a table

@param x table to add
]]
function Heap:push(x)
   self.size = self.size + 1
   self.data[self.size] = x
   x._ind = self.size
   self:siftUp(self.size)
end

--[[--
remove the top thing from the heap

@return said thing
]]
function Heap:pop()
   local x = self.data[1]
   self.data[1] = self.data[self.size]
   self.data[1]._ind = 1
   self.size = self.size - 1
   self:siftDown(1)
   return x
end

--[[--
move something at index i up or down in heap as required

@param i index to rescore
]]
function Heap:rescore(i)
   if i > self.size or i < 1 then
	  return
   end
   if self:siftUp(i) == i then
	  self:siftDown(i)
   end
end

--[[--
   default comparator
]]
Heap.cmp = function(x,y)
   return x < y
end

if isMain then
   heap = Heap.new(function (x, y) return x[1] < y[1] end)

   for i = 100,1,-1 do
	  heap:push({i})
   end
   
   for i = 1,100 do
	  print(heap:pop()[1])
   end
end
return {"heap.lua"}